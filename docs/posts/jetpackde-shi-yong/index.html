<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta content="IE=edge" http-equiv="X-UA-Compatible"/>
        <meta content="text/html; charset=UTF-8" http-equiv="content-type"/>
        <meta content="width=device-width, initial-scale=1" name="viewport"/>

        
        
        

        
        
        

        

        
        
        

        
        
        

        <title>Jetpack介绍</title>
        
        <meta name="title" content="Jetpack介绍">
        <meta name="author" content="sanhuzhen">
        
        <meta name="generator" content="Zola v0.16.1">

        <meta property="og:type" content="website">
        <meta property="og:url" content="https://blog.sanhuzhen.top/posts/jetpackde-shi-yong/">
        <meta property="og:site_name" content="sanhuzhen&#x27;s Blog">
        <meta property="og:title" content="Jetpack介绍">
        
        <meta property="og:image" content="https:&#x2F;&#x2F;blog.sanhuzhen.top&#x2F;images&#x2F;logo.png">

        
        
        <meta property="twitter:card" content="summary_large_image">
        <meta property="twitter:url" content="https://blog.sanhuzhen.top/posts/jetpackde-shi-yong/">
        <meta property="twitter:title" content="Jetpack介绍">
        
        <meta property="twitter:image" content="https:&#x2F;&#x2F;blog.sanhuzhen.top&#x2F;images&#x2F;logo.png">
        
        
        <link rel="canonical" href="https://blog.sanhuzhen.top/posts/jetpackde-shi-yong/">
        <link rel="shortcut icon" type="image/x-icon" href="https://blog.sanhuzhen.top/images/logo.png">
        <script type="application/ld+json">
            {
                
                "url":"https://blog.sanhuzhen.top/posts/jetpackde-shi-yong/",
                "@type":"WebSite",
                "headline":"Jetpack介绍",
                "name":"Jetpack介绍",
                "author":{
                    "@type":"Person",
                    "name":"sanhuzhen"
                },
                "@context":"https://schema.org"
            }
        </script>
        
        
        
        <link rel="stylesheet" href="https://blog.sanhuzhen.top/style.css"/>
        
    </head>
    <body theme="auto">
        <div class="w">
            <header>
                
                <nav>
                    
                    <a href="https://blog.sanhuzhen.top/about" >about</a>
                    
                    <a href="https://blog.sanhuzhen.top" >home</a>
                    
                    <a href="https://blog.sanhuzhen.top/posts" >archive</a>
                    
                    <a href="https://blog.sanhuzhen.top/tags" >tags</a>
                    
                    <a href="https://blog.sanhuzhen.top/categories" >categories</a>
                    
                </nav>
                
                
<p><a href="..">..</a>/jetpackde-shi-yong</p>
<p class="post-meta"><time datetime="2025-03-26">2025-03-26</time></p>
<h1>Jetpack介绍</h1>

            </header>
            <main class="page-content" aria-label="Content">
                



<h1 id="shen-me-shi-jetpack">什么是Jetpack？</h1>
<p>看一下官方的定义：</p>
<blockquote>
<p>Jetpack 是一个由多个库组成的套件，可帮助开发者遵循最佳做法、减少样板代码并编写可在各种 Android 版本和设备中一致运行的代码，让开发者可将精力集中于真正重要的编码工作。</p>
</blockquote>
<p>简单来说，Jetpack就是Google官方推出的一套方便开发者的库。</p>
<p>那么，为什么要使用Jetpack呢？</p>
<p>原因就是因为Android在发展过程中出现了许多框架来帮助开发者快速进行开发，但随着这些框架越来越多，导致了开发越来越碎片化，这时候，大哥Google看不下去了，所以其在Goole I/O 2018大会上推出了Android Jetpack。Jetpack可帮助开发者遵循最佳做法，减少样板代码并编写可在各种 Android 版本和设备中一致运行的代码，让开发者精力集中编写重要的代码。</p>
<p>Jetpack主要包括4个方面，如下图所示，分别是架构（Architecture）、界面（UI）、行为 （Behavior）和基础（Foundation）。</p>
<p><img src="https://redrock.feishu.cn/space/api/box/stream/download/asynccode/?code=YzFmMDQxYzkxYmQ0MzdiNTU0ZTUwNGQ3YzRmMDQ1ZTNfWWRaZURxRWdsS3ZlWmlLdFlJOWU1U3FwUURNNUxoN05fVG9rZW46VEtLaGJHd01KbzVJZVJ4aUxXOGNPRDhSblBsXzE3NDcyMDE5OTE6MTc0NzIwNTU5MV9WNA" alt="img" /></p>
<h1 id="lifecycle">Lifecycle</h1>
<p>Lifecycle是很多Jetpack组件的基础，我们先来讲讲它。</p>
<h2 id="shen-me-shi-lifecycle">什么是Lifecycle？</h2>
<p><a href="https://developer.android.com/topic/libraries/architecture/lifecycle?hl=zh-cn">Lifecycle</a>是一个类，用于存储有关组件（如 activity 或 fragment）的生命周期状态的信息，并允许其他对象观测此状态。</p>
<h2 id="wei-shen-me-yao-yong-lifecycle">为什么要用Lifecycle</h2>
<p>我们在处理Activity和Fragment组件的生命周期相关时，我们一般会在onCreate中初始化某些成员，然后再其他生命周期中对这些成员进行特殊处理，最后在onDestroy中释放他们。我们在一些需求小的时候，这样写是没有问题的，但当你需求过多了，你把这些全都写到里面，会造成你的代码会非常复杂臃肿。为了解决上述问题，就推出了Lifecycle来帮助我们用一种统一的方式来监听 Activity、Fragment 的生命周期变化，并且会大大减少了业务代码发生内存泄漏的风险。</p>
<h2 id="lifecyclede-yong-fa">Lifecycle的用法</h2>
<blockquote>
<p>注：@OnLifecycleEvent(Lifecycle.Event.ON_XXX)标签已经被弃用</p>
</blockquote>
<h3 id="defaultlifecycleobserverjie-kou"><code>DefaultLifecycleObserver</code>接口</h3>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">MyObserver</span><span>: </span><span style="color:#a3be8c;">DefaultLifecycleObserver</span><span> {
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onCreate</span><span>(owner: LifecycleOwner) {
</span><span>        </span><span style="color:#d08770;">super</span><span>.onCreate(owner)
</span><span>        Log.d(&quot;</span><span style="color:#a3be8c;">MyObserver</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">onCreate:</span><span>&quot;)
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onStart</span><span>(owner: LifecycleOwner) {
</span><span>        </span><span style="color:#d08770;">super</span><span>.onStart(owner)
</span><span>        Log.d(&quot;</span><span style="color:#a3be8c;">MyObserver</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">onStart:</span><span>&quot;)
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onResume</span><span>(owner: LifecycleOwner) {
</span><span>        </span><span style="color:#d08770;">super</span><span>.onResume(owner)
</span><span>        Log.d(&quot;</span><span style="color:#a3be8c;">MyObserver</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">onResume:</span><span>&quot;)
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onPause</span><span>(owner: LifecycleOwner) {
</span><span>        </span><span style="color:#d08770;">super</span><span>.onPause(owner)
</span><span>        Log.d(&quot;</span><span style="color:#a3be8c;">MyObserver</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">onPause:</span><span>&quot;)
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onStop</span><span>(owner: LifecycleOwner) {
</span><span>        </span><span style="color:#d08770;">super</span><span>.onStop(owner)
</span><span>        Log.d(&quot;</span><span style="color:#a3be8c;">MyObserver</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">onStop:</span><span>&quot;)
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onDestroy</span><span>(owner: LifecycleOwner) {
</span><span>        </span><span style="color:#d08770;">super</span><span>.onDestroy(owner)
</span><span>        Log.d(&quot;</span><span style="color:#a3be8c;">MyObserver</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">onDestroy:</span><span>&quot;)
</span><span>    }
</span><span>}
</span></code></pre>
<p>在Activity中添加<code>lifecycle.addObserver(MyObserver())</code></p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">LifecycleActivity</span><span>: </span><span style="color:#a3be8c;">AppCompatActivity</span><span>() {
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onCreate</span><span>(savedInstanceState: Bundle?) {
</span><span>        </span><span style="color:#d08770;">super</span><span>.onCreate(savedInstanceState)
</span><span>        setContentView(R.layout.activity_lifecycle)
</span><span>        lifecycle.addObserver(MyObserver())
</span><span>    }
</span><span>}
</span></code></pre>
<p>查看Log</p>
<p><img src="https://redrock.feishu.cn/space/api/box/stream/download/asynccode/?code=YzRhNTFlYjlmZTY2ZjNhMDE2ZjBjYTViN2I2M2Y5ZWRfU0o3NE05ZGV1cVhYb1RqQmxtcGhUTmEyWDlVWXpJdGpfVG9rZW46R05HWmJ4RnNCb1RGa2N4NXdvS2NDQ1ozbnNiXzE3NDcyMDE5OTE6MTc0NzIwNTU5MV9WNA" alt="img" /></p>
<h3 id="lifecycleeventobserverjie-kou"><code>LifecycleEventObserver</code>接口</h3>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">MyObserver2</span><span>: </span><span style="color:#a3be8c;">LifecycleEventObserver</span><span> {
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onStateChanged</span><span>(source: LifecycleOwner, event: Lifecycle.Event) {
</span><span>        </span><span style="color:#b48ead;">when</span><span> (event) {
</span><span>            Lifecycle.Event.</span><span style="color:#d08770;">ON_CREATE </span><span>-&gt; {
</span><span>                Log.d(&quot;</span><span style="color:#a3be8c;">MyObserver2</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">onCreate</span><span>&quot;)
</span><span>            }
</span><span>            Lifecycle.Event.</span><span style="color:#d08770;">ON_START </span><span>-&gt; {
</span><span>                Log.d(&quot;</span><span style="color:#a3be8c;">MyObserver2</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">onStart</span><span>&quot;)
</span><span>            }
</span><span>            Lifecycle.Event.</span><span style="color:#d08770;">ON_RESUME </span><span>-&gt; {
</span><span>                Log.d(&quot;</span><span style="color:#a3be8c;">MyObserver2</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">onResume</span><span>&quot;)
</span><span>            }
</span><span>            Lifecycle.Event.</span><span style="color:#d08770;">ON_PAUSE </span><span>-&gt; {
</span><span>                Log.d(&quot;</span><span style="color:#a3be8c;">MyObserver2</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">onPause</span><span>&quot;)
</span><span>            }
</span><span>            Lifecycle.Event.</span><span style="color:#d08770;">ON_STOP </span><span>-&gt; {
</span><span>                Log.d(&quot;</span><span style="color:#a3be8c;">MyObserver2</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">onStop</span><span>&quot;)
</span><span>            }
</span><span>            Lifecycle.Event.</span><span style="color:#d08770;">ON_DESTROY </span><span>-&gt; {
</span><span>                Log.d(&quot;</span><span style="color:#a3be8c;">MyObserver2</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">onDestroy</span><span>&quot;)
</span><span>            }
</span><span>            </span><span style="color:#b48ead;">else </span><span>-&gt; {}
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>同样在Activity中添加<code>lifecycle.addObserver(MyObserver2())</code></p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">LifecycleActivity</span><span>: </span><span style="color:#a3be8c;">AppCompatActivity</span><span>() {
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onCreate</span><span>(savedInstanceState: Bundle?) {
</span><span>        </span><span style="color:#d08770;">super</span><span>.onCreate(savedInstanceState)
</span><span>        setContentView(R.layout.activity_lifecycle)
</span><span>        lifecycle.addObserver(MyObserver2())
</span><span>    }
</span><span>}
</span></code></pre>
<p><img src="https://redrock.feishu.cn/space/api/box/stream/download/asynccode/?code=MWM4OWY5OTVmMzFlYWVmYWI1MjMzMmE0MjEyYjQ0ZTFfZU1nQlFBc1Q5TW1BVjNVbHlMck1yQ1VNZzZvZnpxZFVfVG9rZW46RURlZmJSN3Nvb1RjU294M1VvemNoSEpnblFmXzE3NDcyMDE5OTE6MTc0NzIwNTU5MV9WNA" alt="img" /></p>
<h2 id="lifecyclede-yuan-li">Lifecycle的原理</h2>
<p>大家是否有这样的疑问，为什么Lifecycle可以监听生命周期？所以带着这样的疑问，我们就来讲讲其原理。</p>
<p>Lifecycle整体上采用了观察者模式，提供了LifecycleOwner(被观察者)和LifecyleObserver(观察者)两个接口，通过这个其就可以对页面的生命周期进行监听。</p>
<p>回到我们的Activity中来，我们注册观察者主要是通过<code>lifecycle</code>调用<code>addObserver()</code>实现的，所以我们从这里下手看看这个<code>lifecycle</code>是咋来的</p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span>lifecycle.addObserver(MyObserver())
</span></code></pre>
<p>咱们按住Ctrl键，用鼠标点击<code>lifecycle</code></p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span style="color:#b48ead;">override val </span><span>lifecycle: Lifecycle
</span><span>    </span><span style="color:#8fa1b3;">get</span><span>() = </span><span style="color:#d08770;">super</span><span>.lifecycle
</span></code></pre>
<p>可以看到这个lifecycle拿的是其父类中的lifecycle，咱们再点进去</p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span>@RestrictTo(RestrictTo.Scope.</span><span style="color:#d08770;">LIBRARY_GROUP_PREFIX</span><span>)
</span><span style="color:#b48ead;">public open class </span><span style="color:#ebcb8b;">ComponentActivity </span><span>: </span><span style="color:#a3be8c;">Activity</span><span>(), </span><span style="color:#a3be8c;">LifecycleOwner</span><span>, </span><span style="color:#a3be8c;">KeyEventDispatcher</span><span>.</span><span style="color:#a3be8c;">Component</span><span> {
</span><span>    ...
</span><span>    @Suppress(&quot;</span><span style="color:#a3be8c;">LeakingThis</span><span>&quot;) </span><span style="color:#b48ead;">private val </span><span>lifecycleRegistry = LifecycleRegistry(</span><span style="color:#d08770;">this</span><span>)
</span><span>    ...
</span><span>    </span><span style="color:#b48ead;">override val </span><span>lifecycle: Lifecycle
</span><span>        </span><span style="color:#8fa1b3;">get</span><span>() = lifecycleRegistry
</span><span>    }
</span><span>}
</span></code></pre>
<p>我们可以看到lifecycle拿到的是一个<code>LifecycleRegistry</code>对象，并且将当前的Activity传进去了</p>
<p>我们再来看看<code>LifecycleRegistry</code>对象</p>
<pre data-lang="Kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-Kotlin "><code class="language-Kotlin" data-lang="Kotlin"><span style="color:#b48ead;">open class </span><span style="color:#ebcb8b;">LifecycleRegistry private constructor</span><span>(
</span><span>    provider: LifecycleOwner,
</span><span>    </span><span style="color:#b48ead;">private val </span><span>enforceMainThread: </span><span style="color:#b48ead;">Boolean
</span><span>) : </span><span style="color:#a3be8c;">Lifecycle</span><span>() {
</span><span>    ...
</span><span>}
</span></code></pre>
<p>可以看到LifecycleRegistry继承于Lifecycle这个类，并且在其构造方法中传进来一个<code>LifecycleOwner</code>，我们看看它</p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span style="color:#b48ead;">public interface </span><span style="color:#ebcb8b;">LifecycleOwner</span><span> {
</span><span>    </span><span style="color:#65737e;">/**
</span><span style="color:#65737e;">     * Returns the Lifecycle of the provider.
</span><span style="color:#65737e;">     *
</span><span style="color:#65737e;">     * @return The lifecycle of the provider.
</span><span style="color:#65737e;">     */
</span><span>    </span><span style="color:#b48ead;">public val </span><span>lifecycle: Lifecycle
</span><span>}
</span></code></pre>
<p>可以看到它是一个接口，里面只有一个变量<code>lifecycle</code>，上面说了<code>LifecycleRegistry</code>将当前的Activity实例传了进来，所以Activity肯定是实现了<code>LifecycleOwner</code>这个接口的，所以，我们就知道<code>lifecycle</code>是怎么来的了。</p>
<p>聊完lifecycle怎么来的之后，我们就可以详细聊一聊它究竟怎么感知生命周期的了。</p>
<p>前面提到了<code>LifecycleRegistry</code>继承于<code>Lifecycle</code>这个类，我们先来看看它</p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span style="color:#b48ead;">public abstract class </span><span style="color:#ebcb8b;">Lifecycle</span><span> {
</span><span>    </span><span style="color:#65737e;">// 添加观察者
</span><span>    @MainThread
</span><span>    </span><span style="color:#b48ead;">public abstract fun </span><span style="color:#8fa1b3;">addObserver</span><span>(observer: LifecycleObserver)
</span><span>    </span><span style="color:#65737e;">// 移除观察者
</span><span>    @MainThread
</span><span>    </span><span style="color:#b48ead;">public abstract fun </span><span style="color:#8fa1b3;">removeObserver</span><span>(observer: LifecycleObserver)
</span><span>    </span><span style="color:#65737e;">// 当前状态
</span><span>    @get:MainThread
</span><span>    </span><span style="color:#b48ead;">public abstract val </span><span>currentState: State
</span><span>    </span><span style="color:#65737e;">// 生命周期事件，对应Activity生命周期方法
</span><span>    </span><span style="color:#b48ead;">public enum class </span><span style="color:#ebcb8b;">Event</span><span> {
</span><span>        </span><span style="color:#d08770;">ON_CREATE</span><span>,
</span><span>        </span><span style="color:#d08770;">ON_START</span><span>,
</span><span>        </span><span style="color:#d08770;">ON_RESUME</span><span>,
</span><span>        </span><span style="color:#d08770;">ON_PAUSE</span><span>,
</span><span>        </span><span style="color:#d08770;">ON_STOP</span><span>,
</span><span>        </span><span style="color:#d08770;">ON_DESTROY</span><span>,
</span><span>        </span><span style="color:#d08770;">ON_ANY</span><span>;
</span><span>        </span><span style="color:#65737e;">// 发生事件后的状态
</span><span>        </span><span style="color:#b48ead;">public val </span><span>targetState: State
</span><span>            </span><span style="color:#8fa1b3;">get</span><span>() {
</span><span>                </span><span style="color:#b48ead;">when</span><span> (</span><span style="color:#d08770;">this</span><span>) {
</span><span>                    </span><span style="color:#d08770;">ON_CREATE</span><span>, </span><span style="color:#d08770;">ON_STOP </span><span>-&gt; </span><span style="color:#b48ead;">return</span><span> State.</span><span style="color:#d08770;">CREATED
</span><span>                    </span><span style="color:#d08770;">ON_START</span><span>, </span><span style="color:#d08770;">ON_PAUSE </span><span>-&gt; </span><span style="color:#b48ead;">return</span><span> State.</span><span style="color:#d08770;">STARTED
</span><span>                    </span><span style="color:#d08770;">ON_RESUME </span><span>-&gt; </span><span style="color:#b48ead;">return</span><span> State.</span><span style="color:#d08770;">RESUMED
</span><span>                    </span><span style="color:#d08770;">ON_DESTROY </span><span>-&gt; </span><span style="color:#b48ead;">return</span><span> State.</span><span style="color:#d08770;">DESTROYED
</span><span>                    </span><span style="color:#d08770;">ON_ANY </span><span>-&gt; {}
</span><span>                }
</span><span>                </span><span style="color:#b48ead;">throw</span><span> IllegalArgumentException(&quot;</span><span style="color:#bf616a;">$this</span><span style="color:#a3be8c;"> has no target state</span><span>&quot;)
</span><span>            } 
</span><span>    }
</span><span>    </span><span style="color:#65737e;">//生命周期状态
</span><span>    </span><span style="color:#b48ead;">public enum class </span><span style="color:#ebcb8b;">State</span><span> {
</span><span>        </span><span style="color:#d08770;">DESTROYED</span><span>,
</span><span>        </span><span style="color:#d08770;">INITIALIZED</span><span>,
</span><span>        </span><span style="color:#d08770;">CREATED</span><span>,
</span><span>        </span><span style="color:#d08770;">STARTED</span><span>,
</span><span>        </span><span style="color:#d08770;">RESUMED</span><span>;
</span><span>        </span><span style="color:#65737e;">//判断至少是某一状态
</span><span>        </span><span style="color:#b48ead;">public fun </span><span style="color:#8fa1b3;">isAtLeast</span><span>(state: State): </span><span style="color:#b48ead;">Boolean</span><span> {
</span><span>            </span><span style="color:#b48ead;">return</span><span> compareTo(state) &gt;= </span><span style="color:#d08770;">0
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>可以看到Lifecycle是一个抽象类，里面定义了一些抽象方法以及两种枚举：<strong>事件</strong>和<strong>状态</strong>，Lifecycle正是用这两种枚举跟踪其关联组件的生命周期状态，当我们的事件发生后，我们会把Lifecycle的状态也改变。</p>
<p>ok，聊完Lifecycle这个类之后，我们上面了解到Activity是实现了<code>LifecycleOwner</code>这个接口的，那么处理生命周期的一些方法肯定在Activity中存在的，我们来看看<em>androidx.activity.ComponentActivity</em></p>
<pre data-lang="Kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-Kotlin "><code class="language-Kotlin" data-lang="Kotlin"><span style="color:#b48ead;">open class </span><span style="color:#ebcb8b;">ComponentActivity</span><span>() :
</span><span>    androidx.core.app.ComponentActivity(),
</span><span>    ContextAware,
</span><span>    LifecycleOwner {
</span><span>    ...
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onCreate</span><span>(savedInstanceState: Bundle?) {
</span><span>        savedStateRegistryController.performRestore(savedInstanceState)
</span><span>        contextAwareHelper.dispatchOnContextAvailable(</span><span style="color:#d08770;">this</span><span>)
</span><span>        </span><span style="color:#d08770;">super</span><span>.onCreate(savedInstanceState)
</span><span>        ReportFragment.injectIfNeededIn(</span><span style="color:#d08770;">this</span><span>)</span><span style="color:#65737e;">// 关键
</span><span>        </span><span style="color:#b48ead;">if</span><span> (contentLayoutId != </span><span style="color:#d08770;">0</span><span>) {
</span><span>            setContentView(contentLayoutId)
</span><span>        }
</span><span>    }
</span><span>
</span><span>    @CallSuper
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onSaveInstanceState</span><span>(outState: Bundle) {
</span><span>        </span><span style="color:#b48ead;">if</span><span> (lifecycle is LifecycleRegistry) {
</span><span>            (lifecycle as LifecycleRegistry).currentState = Lifecycle.State.</span><span style="color:#d08770;">CREATED
</span><span>        }
</span><span>        </span><span style="color:#d08770;">super</span><span>.onSaveInstanceState(outState)
</span><span>        savedStateRegistryController.performSave(outState)
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">override val </span><span>lifecycle: Lifecycle
</span><span>        </span><span style="color:#8fa1b3;">get</span><span>() = </span><span style="color:#d08770;">super</span><span>.lifecycle
</span><span>}
</span></code></pre>
<p>我们可以看到，好像只是在<code>onSaveInstanceState</code>中设置了Lifecycle的State为CREATED，这是咋回事？其他的生命周期呢？其实是在onCreate中的<code>ReportFragment.injectIfNeededIn(this)</code>才是关键。</p>
<p>我们来点进去，还是有很多东西的</p>
<p>我们来慢慢看，首先我们先从<code>injectIfNeededIn</code>这个方法看起</p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span>        @JvmStatic
</span><span>        </span><span style="color:#b48ead;">fun </span><span style="color:#8fa1b3;">injectIfNeededIn</span><span>(activity: Activity) {
</span><span>            </span><span style="color:#65737e;">// 当API 29 以上直接注册回调
</span><span>            </span><span style="color:#b48ead;">if</span><span> (Build.</span><span style="color:#d08770;">VERSION</span><span>.</span><span style="color:#d08770;">SDK_INT </span><span>&gt;= </span><span style="color:#d08770;">29</span><span>) {
</span><span>                LifecycleCallbacks.registerIn(activity)
</span><span>            }
</span><span>            </span><span style="color:#b48ead;">val </span><span>manager = activity.fragmentManager
</span><span>            </span><span style="color:#b48ead;">if</span><span> (manager.findFragmentByTag(</span><span style="color:#d08770;">REPORT_FRAGMENT_TAG</span><span>) == </span><span style="color:#d08770;">null</span><span>) {
</span><span>                manager.beginTransaction().add(ReportFragment(), </span><span style="color:#d08770;">REPORT_FRAGMENT_TAG</span><span>).commit()
</span><span>                manager.executePendingTransactions()
</span><span>            }
</span><span>        }
</span></code></pre>
<p>可以看到这个方法是分了版本的，API 29之前是添加了一个<code>ReportFragment()</code>给当前Activity，之后使用了LifecycleCallbacks。咱们先来看看老版本的</p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span>@Suppress(&quot;</span><span style="color:#a3be8c;">DEPRECATION</span><span>&quot;)
</span><span>@RestrictTo(RestrictTo.Scope.</span><span style="color:#d08770;">LIBRARY_GROUP_PREFIX</span><span>)
</span><span style="color:#b48ead;">open class </span><span style="color:#ebcb8b;">ReportFragment</span><span>() : </span><span style="color:#a3be8c;">android</span><span>.</span><span style="color:#a3be8c;">app</span><span>.</span><span style="color:#a3be8c;">Fragment</span><span>() {
</span><span>
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onActivityCreated</span><span>(savedInstanceState: Bundle?) {
</span><span>        </span><span style="color:#d08770;">super</span><span>.onActivityCreated(savedInstanceState)
</span><span>        dispatchCreate(processListener)
</span><span>        dispatch(Lifecycle.Event.</span><span style="color:#d08770;">ON_CREATE</span><span>)
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onStart</span><span>() {
</span><span>        </span><span style="color:#d08770;">super</span><span>.onStart()
</span><span>        dispatchStart(processListener)
</span><span>        dispatch(Lifecycle.Event.</span><span style="color:#d08770;">ON_START</span><span>)
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onResume</span><span>() {
</span><span>        </span><span style="color:#d08770;">super</span><span>.onResume()
</span><span>        dispatchResume(processListener)
</span><span>        dispatch(Lifecycle.Event.</span><span style="color:#d08770;">ON_RESUME</span><span>)
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onPause</span><span>() {
</span><span>        </span><span style="color:#d08770;">super</span><span>.onPause()
</span><span>        dispatch(Lifecycle.Event.</span><span style="color:#d08770;">ON_PAUSE</span><span>)
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onStop</span><span>() {
</span><span>        </span><span style="color:#d08770;">super</span><span>.onStop()
</span><span>        dispatch(Lifecycle.Event.</span><span style="color:#d08770;">ON_STOP</span><span>)
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onDestroy</span><span>() {
</span><span>        </span><span style="color:#d08770;">super</span><span>.onDestroy()
</span><span>        dispatch(Lifecycle.Event.</span><span style="color:#d08770;">ON_DESTROY</span><span>)
</span><span>        </span><span style="color:#65737e;">// just want to be sure that we won&#39;t leak reference to an activity
</span><span>        processListener = </span><span style="color:#d08770;">null
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">private fun </span><span style="color:#8fa1b3;">dispatch</span><span>(event: Lifecycle.Event) {
</span><span>        </span><span style="color:#b48ead;">if</span><span> (Build.</span><span style="color:#d08770;">VERSION</span><span>.</span><span style="color:#d08770;">SDK_INT </span><span>&lt; </span><span style="color:#d08770;">29</span><span>) {
</span><span>            </span><span style="color:#65737e;">// Only dispatch events from ReportFragment on API levels prior
</span><span>            </span><span style="color:#65737e;">// to API 29. On API 29+, this is handled by the ActivityLifecycleCallbacks
</span><span>            </span><span style="color:#65737e;">// added in ReportFragment.injectIfNeededIn
</span><span>            dispatch(activity, event)
</span><span>        }
</span><span>    }
</span><span> }
</span></code></pre>
<p>可以看到，都在当前生命周期中用到了<code>dispatch</code>方法，当生命周期被触发后，会传一个对应的事件给它，并且这个方法里面又用到了一个<code>dispatch</code>方法，我们后面再来看这个方法。</p>
<p>我们先来看看API 29以上是怎么处理的？</p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span>@RequiresApi(</span><span style="color:#d08770;">29</span><span>)
</span><span style="color:#b48ead;">internal class </span><span style="color:#ebcb8b;">LifecycleCallbacks </span><span>: </span><span style="color:#a3be8c;">Application</span><span>.</span><span style="color:#a3be8c;">ActivityLifecycleCallbacks</span><span> {
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onActivityCreated</span><span>(
</span><span>        activity: Activity,
</span><span>        bundle: Bundle?
</span><span>    ) {}
</span><span>
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onActivityPostCreated</span><span>(
</span><span>        activity: Activity,
</span><span>        savedInstanceState: Bundle?
</span><span>    ) {
</span><span>        dispatch(activity, Lifecycle.Event.</span><span style="color:#d08770;">ON_CREATE</span><span>)
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onActivityStarted</span><span>(activity: Activity) {}
</span><span>
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onActivityPostStarted</span><span>(activity: Activity) {
</span><span>        dispatch(activity, Lifecycle.Event.</span><span style="color:#d08770;">ON_START</span><span>)
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onActivityResumed</span><span>(activity: Activity) {}
</span><span>
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onActivityPostResumed</span><span>(activity: Activity) {
</span><span>        dispatch(activity, Lifecycle.Event.</span><span style="color:#d08770;">ON_RESUME</span><span>)
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onActivityPrePaused</span><span>(activity: Activity) {
</span><span>        dispatch(activity, Lifecycle.Event.</span><span style="color:#d08770;">ON_PAUSE</span><span>)
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onActivityPaused</span><span>(activity: Activity) {}
</span><span>
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onActivityPreStopped</span><span>(activity: Activity) {
</span><span>        dispatch(activity, Lifecycle.Event.</span><span style="color:#d08770;">ON_STOP</span><span>)
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onActivityStopped</span><span>(activity: Activity) {}
</span><span>
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onActivitySaveInstanceState</span><span>(
</span><span>        activity: Activity,
</span><span>        bundle: Bundle
</span><span>    ) {}
</span><span>
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onActivityPreDestroyed</span><span>(activity: Activity) {
</span><span>        dispatch(activity, Lifecycle.Event.</span><span style="color:#d08770;">ON_DESTROY</span><span>)
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onActivityDestroyed</span><span>(activity: Activity) {}
</span><span>
</span><span>    </span><span style="color:#b48ead;">companion object</span><span> {
</span><span>        @JvmStatic
</span><span>        </span><span style="color:#b48ead;">fun </span><span style="color:#8fa1b3;">registerIn</span><span>(activity: Activity) {
</span><span>            activity.registerActivityLifecycleCallbacks(LifecycleCallbacks())
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>我们可以看到，API 29以上同样也是用到了<code>dispacth</code>方法，只不过它是直接使用activity的registerActivityLifecycleCallbacks 直接注册了生命周期回调，然后给当前Activity添加ReportFragment。</p>
<p>所以，让我们来看看dispatch这个方法</p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span>@JvmStatic
</span><span style="color:#b48ead;">internal fun </span><span style="color:#8fa1b3;">dispatch</span><span>(activity: Activity, event: Lifecycle.Event) {
</span><span>    </span><span style="color:#b48ead;">if</span><span> (activity is LifecycleRegistryOwner) {
</span><span>        activity.lifecycle.handleLifecycleEvent(event)
</span><span>        </span><span style="color:#b48ead;">return
</span><span>    }
</span><span>    </span><span style="color:#b48ead;">if</span><span> (activity is LifecycleOwner) {
</span><span>        </span><span style="color:#b48ead;">val </span><span>lifecycle = (activity as LifecycleOwner).lifecycle
</span><span>        </span><span style="color:#b48ead;">if</span><span> (lifecycle is LifecycleRegistry) {
</span><span>            lifecycle.handleLifecycleEvent(event)
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>可以看到，在内部都是使用到了<code>lifecycle.handleLifecycleEvent(event)</code>，我们来看看它。</p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span style="color:#b48ead;">open fun </span><span style="color:#8fa1b3;">handleLifecycleEvent</span><span>(event: Event) {
</span><span>    enforceMainThreadIfNeeded(&quot;</span><span style="color:#a3be8c;">handleLifecycleEvent</span><span>&quot;)
</span><span>    </span><span style="color:#65737e;">// 开始对当前事务发生后的State做处理
</span><span>    moveToState(event.targetState)
</span><span>}
</span><span>
</span><span style="color:#b48ead;">private fun </span><span style="color:#8fa1b3;">moveToState</span><span>(next: State) {
</span><span>    </span><span style="color:#65737e;">// 如果当前State与即将要发生变化的State一样，直接返回
</span><span>    </span><span style="color:#b48ead;">if</span><span> (state == next) {
</span><span>        </span><span style="color:#b48ead;">return
</span><span>    }
</span><span>    check(!(state == State.</span><span style="color:#d08770;">INITIALIZED </span><span>&amp;&amp; next == State.</span><span style="color:#d08770;">DESTROYED</span><span>)) {
</span><span>        &quot;</span><span style="color:#a3be8c;">no event down from </span><span style="color:#bf616a;">$state</span><span style="color:#a3be8c;"> in component </span><span style="color:#bf616a;">${lifecycleOwner.get()}</span><span>&quot;
</span><span>    }
</span><span>    </span><span style="color:#65737e;">// 赋值新State
</span><span>    state = next
</span><span>    </span><span style="color:#b48ead;">if</span><span> (handlingEvent || addingObserverCounter != </span><span style="color:#d08770;">0</span><span>) {
</span><span>        newEventOccurred = </span><span style="color:#d08770;">true
</span><span>        </span><span style="color:#65737e;">// we will figure out what to do on upper level.
</span><span>        </span><span style="color:#b48ead;">return
</span><span>    }
</span><span>    handlingEvent = </span><span style="color:#d08770;">true
</span><span>    </span><span style="color:#65737e;">// 把新的State同步给所有的观察者
</span><span>    sync()
</span><span>    handlingEvent = </span><span style="color:#d08770;">false
</span><span>    </span><span style="color:#b48ead;">if</span><span> (state == State.</span><span style="color:#d08770;">DESTROYED</span><span>) {
</span><span>        observerMap = FastSafeIterableMap()
</span><span>    }
</span><span>}
</span></code></pre>
<p>这里应该比较好理解，就是那边传了一个事务过来，我们去改变当前State，相同返回，不一样就要同步给所有的观察者，所以我们来看看sync这个方法</p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span style="color:#b48ead;">private val </span><span>isSynced: </span><span style="color:#b48ead;">Boolean
</span><span>    </span><span style="color:#8fa1b3;">get</span><span>() {
</span><span>        </span><span style="color:#65737e;">// observerMap就是 在activity中添加observer后 用于存放observer的map
</span><span>        </span><span style="color:#b48ead;">if</span><span> (observerMap.size() == </span><span style="color:#d08770;">0</span><span>) {
</span><span>            </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">true
</span><span>        }
</span><span>        </span><span style="color:#b48ead;">val</span><span> eldestObserverState = observerMap.eldest()!!.value.state
</span><span>        </span><span style="color:#b48ead;">val</span><span> newestObserverState = observerMap.newest()!!.value.state
</span><span>        </span><span style="color:#b48ead;">return</span><span> eldestObserverState == newestObserverState &amp;&amp; state == newestObserverState
</span><span>    }
</span><span>
</span><span style="color:#b48ead;">private fun </span><span style="color:#8fa1b3;">sync</span><span>() {
</span><span>    </span><span style="color:#b48ead;">val </span><span>lifecycleOwner = lifecycleOwner.</span><span style="color:#8fa1b3;">get</span><span>()
</span><span>        ?: </span><span style="color:#b48ead;">throw</span><span> IllegalStateException(
</span><span>            &quot;</span><span style="color:#a3be8c;">LifecycleOwner of this LifecycleRegistry is already </span><span>&quot; +
</span><span>                &quot;</span><span style="color:#a3be8c;">garbage collected. It is too late to change lifecycle state.</span><span>&quot;
</span><span>        )
</span><span>    </span><span style="color:#65737e;">// 一个循环，isSynced表示是否同步给了所有观察者
</span><span>    </span><span style="color:#b48ead;">while</span><span> (!isSynced) {
</span><span>        newEventOccurred = </span><span style="color:#d08770;">false
</span><span>        </span><span style="color:#b48ead;">if</span><span> (state &lt; observerMap.eldest()!!.value.state) {
</span><span>            backwardPass(lifecycleOwner)
</span><span>        }
</span><span>        </span><span style="color:#b48ead;">val </span><span>newest = observerMap.newest()
</span><span>        </span><span style="color:#b48ead;">if</span><span> (!newEventOccurred &amp;&amp; newest != </span><span style="color:#d08770;">null </span><span>&amp;&amp; state &gt; newest.value.state) {
</span><span>            forwardPass(lifecycleOwner)
</span><span>        }
</span><span>    }
</span><span>    newEventOccurred = </span><span style="color:#d08770;">false
</span><span>}
</span></code></pre>
<p>可以看到，sync就是用来同步所有的observerMap中的观察者，那观察者是怎么被加进来的呢？答案自然是我们在Activity中使用的<code>addObserver()</code></p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">addObserver</span><span>(observer: LifecycleObserver) {
</span><span>    enforceMainThreadIfNeeded(&quot;</span><span style="color:#a3be8c;">addObserver</span><span>&quot;)
</span><span>    </span><span style="color:#b48ead;">val </span><span>initialState = </span><span style="color:#b48ead;">if</span><span> (state == State.</span><span style="color:#d08770;">DESTROYED</span><span>) State.</span><span style="color:#d08770;">DESTROYED </span><span style="color:#b48ead;">else</span><span> State.</span><span style="color:#d08770;">INITIALIZED
</span><span>    </span><span style="color:#65737e;">// 这边用了一个ObserverWithState来管理observer的状态
</span><span>    </span><span style="color:#b48ead;">val </span><span>statefulObserver = ObserverWithState(observer, initialState)
</span><span>    </span><span style="color:#65737e;">// 添加观察者，如果不存在，返回null，存在，返回已经存在的值
</span><span>    </span><span style="color:#b48ead;">val </span><span>previous = observerMap.putIfAbsent(observer, statefulObserver)
</span><span>    </span><span style="color:#65737e;">// 如果存在，直接返回，避免重复添加
</span><span>    </span><span style="color:#b48ead;">if</span><span> (previous != </span><span style="color:#d08770;">null</span><span>) {
</span><span>        </span><span style="color:#b48ead;">return
</span><span>    }
</span><span>    </span><span style="color:#b48ead;">val </span><span>lifecycleOwner = lifecycleOwner.</span><span style="color:#8fa1b3;">get</span><span>()
</span><span>        ?: </span><span style="color:#65737e;">// it is null we should be destroyed. Fallback quickly
</span><span>        </span><span style="color:#b48ead;">return
</span><span>    </span><span style="color:#65737e;">// 下面代码的逻辑：通过while循环，把新的观察者的状态 连续地 同步到最新状态
</span><span>    </span><span style="color:#b48ead;">val </span><span>isReentrance = addingObserverCounter != </span><span style="color:#d08770;">0 </span><span>|| handlingEvent
</span><span>    </span><span style="color:#b48ead;">var </span><span>targetState = calculateTargetState(observer)
</span><span>    addingObserverCounter++
</span><span>    </span><span style="color:#b48ead;">while</span><span> (statefulObserver.state &lt; targetState &amp;&amp; observerMap.contains(observer)) {
</span><span>        pushParentState(statefulObserver.state)
</span><span>        </span><span style="color:#b48ead;">val </span><span>event = Event.upFrom(statefulObserver.state)
</span><span>            ?: </span><span style="color:#b48ead;">throw</span><span> IllegalStateException(&quot;</span><span style="color:#a3be8c;">no event up from </span><span style="color:#bf616a;">${statefulObserver.state}</span><span>&quot;)
</span><span>        statefulObserver.dispatchEvent(lifecycleOwner, event)
</span><span>        popParentState()
</span><span>        </span><span style="color:#65737e;">// mState / subling may have been changed recalculate
</span><span>        targetState = calculateTargetState(observer)
</span><span>    }
</span><span>    </span><span style="color:#65737e;">// 这里如果不是嵌套的添加，我们就又调用sync这个方法
</span><span>    </span><span style="color:#b48ead;">if</span><span> (!isReentrance) {
</span><span>        </span><span style="color:#65737e;">// we do sync only on the top level.
</span><span>        sync()
</span><span>    }
</span><span>    addingObserverCounter--
</span><span>}
</span></code></pre>
<p>我们是在onCreate里面添加观察者的，那你有没有想过如果我在onStart，onResume中去添加观察者可不可以呢？答案是可以的，假如你在onResume中添加，那他会不会回调onCreate，onStart里面的方法呢，是会的，关键就在于<code>statefulObserver.dispatchEvent(lifecycleOwner, event)</code>，我们点进去看看</p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span style="color:#b48ead;">internal class </span><span style="color:#ebcb8b;">ObserverWithState</span><span>(observer: LifecycleObserver?, initialState: State) {
</span><span>    </span><span style="color:#b48ead;">var </span><span>state: State
</span><span>    </span><span style="color:#b48ead;">var </span><span>lifecycleObserver: LifecycleEventObserver
</span><span>
</span><span>    init {
</span><span>        lifecycleObserver = Lifecycling.lifecycleEventObserver(observer!!)
</span><span>        state = initialState
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">fun </span><span style="color:#8fa1b3;">dispatchEvent</span><span>(owner: LifecycleOwner?, event: Event) {
</span><span>        </span><span style="color:#b48ead;">val </span><span>newState = event.targetState
</span><span>        state = min(state, newState)
</span><span>        lifecycleObserver.onStateChanged(owner!!, event)
</span><span>        state = newState
</span><span>    }
</span><span>}
</span></code></pre>
<p>有没有对<code>LifecycleEventObserver</code>这个类有点熟悉，我们的MyObserver2是不是实现了这个接口，所以这里就是将我们自己写的观察者传了进来。</p>
<p>好，这里知道了这个循环的作用，我们在来看看sync这个方法是咋同步observer的State的，</p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span style="color:#b48ead;">private fun </span><span style="color:#8fa1b3;">sync</span><span>() {
</span><span>    </span><span style="color:#b48ead;">val </span><span>lifecycleOwner = lifecycleOwner.</span><span style="color:#8fa1b3;">get</span><span>()
</span><span>        ?: </span><span style="color:#b48ead;">throw</span><span> IllegalStateException(
</span><span>            &quot;</span><span style="color:#a3be8c;">LifecycleOwner of this LifecycleRegistry is already </span><span>&quot; +
</span><span>                &quot;</span><span style="color:#a3be8c;">garbage collected. It is too late to change lifecycle state.</span><span>&quot;
</span><span>        )
</span><span>    </span><span style="color:#65737e;">// 一个循环，isSynced表示是否同步给了所有观察者
</span><span>    </span><span style="color:#b48ead;">while</span><span> (!isSynced) {
</span><span>        newEventOccurred = </span><span style="color:#d08770;">false
</span><span>        </span><span style="color:#b48ead;">if</span><span> (state &lt; observerMap.eldest()!!.value.state) {
</span><span>            backwardPass(lifecycleOwner)
</span><span>        }
</span><span>        </span><span style="color:#b48ead;">val </span><span>newest = observerMap.newest()
</span><span>        </span><span style="color:#b48ead;">if</span><span> (!newEventOccurred &amp;&amp; newest != </span><span style="color:#d08770;">null </span><span>&amp;&amp; state &gt; newest.value.state) {
</span><span>            forwardPass(lifecycleOwner)
</span><span>        }
</span><span>    }
</span><span>    newEventOccurred = </span><span style="color:#d08770;">false
</span><span>}
</span></code></pre>
<p>可以看到在这个循环中有两个方法<code>backwardPass(lifecycleOwner)</code>和<code>forwardPass(lifecycleOwner)</code>，其实这两个方法差不多，就是判断该观察者的State与当前的State进行判断，如果小于，即让其生命周期往前走（onCreate ---&gt; onStart），否则，往后。我们来看看往后走的</p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span style="color:#b48ead;">private fun </span><span style="color:#8fa1b3;">backwardPass</span><span>(lifecycleOwner: LifecycleOwner) {
</span><span>    </span><span style="color:#b48ead;">val </span><span>descendingIterator = observerMap.descendingIterator()
</span><span>    </span><span style="color:#b48ead;">while</span><span> (descendingIterator.hasNext() &amp;&amp; !newEventOccurred) {
</span><span>        </span><span style="color:#b48ead;">val</span><span> (key, observer) = descendingIterator.next()
</span><span>        </span><span style="color:#b48ead;">while</span><span> (observer.state &gt; state &amp;&amp; !newEventOccurred &amp;&amp; observerMap.contains(key)
</span><span>        ) {
</span><span>            </span><span style="color:#b48ead;">val </span><span>event = Event.downFrom(observer.state)
</span><span>                ?: </span><span style="color:#b48ead;">throw</span><span> IllegalStateException(&quot;</span><span style="color:#a3be8c;">no event down from </span><span style="color:#bf616a;">${observer.state}</span><span>&quot;)
</span><span>            pushParentState(event.targetState)
</span><span>            observer.dispatchEvent(lifecycleOwner, event)
</span><span>            popParentState()
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>可以看到这里还是调用了<code>observer.dispatchEvent(lifecycleOwner, event)</code>这个方法去同步，并且之前，得到了一个事件</p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span>@JvmStatic
</span><span style="color:#b48ead;">public fun </span><span style="color:#8fa1b3;">downFrom</span><span>(state: State): Event? {
</span><span>    </span><span style="color:#b48ead;">return when</span><span> (state) {
</span><span>        State.</span><span style="color:#d08770;">CREATED </span><span>-&gt; </span><span style="color:#d08770;">ON_DESTROY
</span><span>        State.</span><span style="color:#d08770;">STARTED </span><span>-&gt; </span><span style="color:#d08770;">ON_STOP
</span><span>        State.</span><span style="color:#d08770;">RESUMED </span><span>-&gt; </span><span style="color:#d08770;">ON_PAUSE
</span><span>        </span><span style="color:#b48ead;">else </span><span>-&gt; </span><span style="color:#d08770;">null
</span><span>    }
</span><span>}
</span></code></pre>
<p>网上有张图，描述了事件与状态的变化</p>
<p><img src="https://redrock.feishu.cn/space/api/box/stream/download/asynccode/?code=ODNkNmNmNDU4ODRjYWQ0NjM3ZmQ0NmMwYjIzZjhjMmNfMXhiZWwwdWFWVTh0Mlg5WjlxRENkSFU2aEhCbWVIN0lfVG9rZW46WUxGUmJSYXhpb0tQeU94Snc2b2NETlA5blZmXzE3NDcyMDE5OTE6MTc0NzIwNTU5MV9WNA" alt="img" /></p>
<h1 id="livedata">LiveData</h1>
<h2 id="shen-me-shi-livedata">什么是LiveData？</h2>
<p>官方定义：</p>
<blockquote>
<p><a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData">LiveData </a>是一种可观察的数据存储器类。与常规的可观察类不同，LiveData 具有生命周期感知能力，意指它遵循其他应用组件（如 Activity/Fragment）的生命周期。这种感知能力可确保 LiveData 仅更新处于活跃生命周期状态的应用组件观察者。</p>
</blockquote>
<p>简单来说，LiveData就是一个数据的持有者，数据被包装后，可以被observer观察，当数据发生变化是observer可以感知到，但这种感知，只会发生在<strong>LifecycleOwner的活跃生命周期状态（STARTED,RESUMED）</strong></p>
<h2 id="livedatade-hao-chu">LiveData的好处</h2>
<ul>
<li>确保UI与数据状态匹配</li>
</ul>
<p>当我们的数据发生变化时，可以通知到UI更新</p>
<ul>
<li>避免内存泄漏</li>
</ul>
<p>观察者绑定到lifecycle对象上，当与之绑定的lifecycle销毁时，他们会自动被清理</p>
<ul>
<li>不会给已经停止的Activity发送消息</li>
</ul>
<p>当所绑定的lifecycle处于非活跃状态时，比如处于栈中的Activity，不会受到任何LiveData的消息</p>
<ul>
<li>不需要手动处理生命周期</li>
</ul>
<p>LiveData具备生命周期感知能力，UI只需对相关的数据进行监听</p>
<ul>
<li>系统配置更改时，进行数据的保存和恢复，及 UI 的恢复</li>
</ul>
<p>当Activity与Fragment发生配置更改而重新构建时（如，旋转手机屏幕），会收到最新的消息</p>
<ul>
<li>资源共享</li>
</ul>
<p>我们可以用单例模式来扩展LiveData，当数据发生变化时，就会通知所有的观察者</p>
<h2 id="livedatade-yong-fa">LiveData的用法</h2>
<p>LiveData是一个抽象类，不能直接使用。通常我们使用的是它的直接子类<code>MutableLiveData</code>。</p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">LiveDataActivity</span><span>: </span><span style="color:#a3be8c;">AppCompatActivity</span><span>() {
</span><span>
</span><span>    </span><span style="color:#b48ead;">private val </span><span>mLiveData = MutableLiveData&lt;</span><span style="color:#b48ead;">String</span><span>&gt;()
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onCreate</span><span>(savedInstanceState: Bundle?) {
</span><span>        </span><span style="color:#d08770;">super</span><span>.onCreate(savedInstanceState)
</span><span>        setContentView(R.layout.activity_livedata)
</span><span>        </span><span style="color:#b48ead;">val </span><span>mTextView: TextView = findViewById(R.id.textView)
</span><span>        </span><span style="color:#b48ead;">val </span><span>button: Button = findViewById(R.id.button)
</span><span>        button.setOnClickListener {
</span><span>            mLiveData.value = &quot;</span><span style="color:#a3be8c;">值被改变了</span><span>&quot;
</span><span>        }
</span><span>        mLiveData.observe(</span><span style="color:#d08770;">this</span><span>) {
</span><span>            mTextView.text = it
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>可以看到，用法还是挺简单的，先定义了一个MutableLiveData对象mLiveData，然后去改变里面所包装的数据，怎么改变的呢？提供了两种方法，<code>setValue</code>和<code>postValue</code>（子线程使用），然后我们后面观察，传入的是拥有生命周期的组件，还有一个当收到数据之后的回调，我们这里将TextView的文本进行改变。</p>
<h2 id="livedatade-yuan-li">LiveData的原理</h2>
<p>跟Lifecycle一样我们从observe这个方法看起，</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span>@</span><span style="color:#bf616a;">MainThread
</span><span style="color:#b48ead;">public</span><span> void </span><span style="color:#bf616a;">observe</span><span>(@</span><span style="color:#ebcb8b;">NonNull LifecycleOwner</span><span> owner, @</span><span style="color:#ebcb8b;">NonNull Observer</span><span>&lt;? </span><span style="color:#b48ead;">super </span><span style="color:#ebcb8b;">T</span><span>&gt; observer) {
</span><span>    </span><span style="color:#bf616a;">assertMainThread</span><span>(&quot;</span><span style="color:#a3be8c;">observe</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">if </span><span>(owner.</span><span style="color:#bf616a;">getLifecycle</span><span>().</span><span style="color:#bf616a;">getCurrentState</span><span>() == </span><span style="color:#d08770;">DESTROYED</span><span>) {
</span><span>        </span><span style="color:#65737e;">// ignore
</span><span>        </span><span style="color:#b48ead;">return</span><span>;
</span><span>    }
</span><span>    </span><span style="color:#ebcb8b;">LifecycleBoundObserver</span><span> wrapper = </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">LifecycleBoundObserver</span><span>(owner, observer);
</span><span>    </span><span style="color:#ebcb8b;">ObserverWrapper</span><span> existing = mObservers.</span><span style="color:#bf616a;">putIfAbsent</span><span>(observer, wrapper);
</span><span>    </span><span style="color:#b48ead;">if </span><span>(existing != </span><span style="color:#d08770;">null </span><span>&amp;&amp; !existing.</span><span style="color:#bf616a;">isAttachedTo</span><span>(owner)) {
</span><span>        </span><span style="color:#b48ead;">throw new </span><span style="color:#ebcb8b;">IllegalArgumentException</span><span>(&quot;</span><span style="color:#a3be8c;">Cannot add the same observer</span><span>&quot;
</span><span>                + &quot;</span><span style="color:#a3be8c;"> with different lifecycles</span><span>&quot;);
</span><span>    }
</span><span>    </span><span style="color:#b48ead;">if </span><span>(existing != </span><span style="color:#d08770;">null</span><span>) {
</span><span>        </span><span style="color:#b48ead;">return</span><span>;
</span><span>    }
</span><span>    owner.</span><span style="color:#bf616a;">getLifecycle</span><span>().</span><span style="color:#bf616a;">addObserver</span><span>(wrapper);
</span><span>}
</span></code></pre>
<p>可以看到，当LifecycleOwner的状态为DESTROYED时，直接返回，然后用我们呢传进来的owner和observer组装成了一个新的类LifecycleBoundObserver，然后使用putIfAbsent方法observer-wrapper作为key-value添加到观察者列表mObservers中。（putIfAbsent意思是只有列表中没有这个observer时才会添加），最后用LifecycleOwner的Lifecycle添加observer的封装wrapper</p>
<p>既然我们最后是用Lifecycle将我们的观察者wrapper加进去的，所以我们来看看LifecycleBoundObserver类</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">LifecycleBoundObserver </span><span style="color:#b48ead;">extends </span><span style="color:#a3be8c;">ObserverWrapper </span><span style="color:#b48ead;">implements </span><span style="color:#a3be8c;">LifecycleEventObserver </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">    @</span><span style="color:#bf616a;">NonNull
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">final </span><span style="color:#ebcb8b;">LifecycleOwner </span><span style="color:#eff1f5;">mOwner;
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#8fa1b3;">LifecycleBoundObserver</span><span style="color:#eff1f5;">(@</span><span style="color:#bf616a;">NonNull </span><span style="color:#ebcb8b;">LifecycleOwner </span><span style="color:#bf616a;">owner</span><span style="color:#eff1f5;">, </span><span style="color:#ebcb8b;">Observer</span><span style="color:#eff1f5;">&lt;</span><span>? </span><span style="color:#b48ead;">super </span><span style="color:#ebcb8b;">T</span><span style="color:#eff1f5;">&gt; </span><span style="color:#bf616a;">observer</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        </span><span style="color:#bf616a;">super</span><span style="color:#eff1f5;">(observer);
</span><span style="color:#eff1f5;">        mOwner </span><span>=</span><span style="color:#eff1f5;"> owner;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">// STARTED状态或者RESUME状态
</span><span style="color:#eff1f5;">    @</span><span style="color:#bf616a;">Override
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">boolean </span><span style="color:#8fa1b3;">shouldBeActive</span><span style="color:#eff1f5;">() {
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;"> mOwner.</span><span style="color:#bf616a;">getLifecycle</span><span style="color:#eff1f5;">().</span><span style="color:#bf616a;">getCurrentState</span><span style="color:#eff1f5;">().</span><span style="color:#bf616a;">isAtLeast</span><span style="color:#eff1f5;">(</span><span style="color:#d08770;">STARTED</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    @</span><span style="color:#bf616a;">Override
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">public void </span><span style="color:#8fa1b3;">onStateChanged</span><span style="color:#eff1f5;">(@</span><span style="color:#bf616a;">NonNull </span><span style="color:#ebcb8b;">LifecycleOwner </span><span style="color:#bf616a;">source</span><span style="color:#eff1f5;">,
</span><span style="color:#eff1f5;">            @</span><span style="color:#bf616a;">NonNull </span><span style="color:#ebcb8b;">Lifecycle</span><span style="color:#eff1f5;">.</span><span style="color:#ebcb8b;">Event </span><span style="color:#bf616a;">event</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">Lifecycle</span><span style="color:#eff1f5;">.</span><span style="color:#ebcb8b;">State</span><span style="color:#eff1f5;"> currentState </span><span>=</span><span style="color:#eff1f5;"> mOwner.</span><span style="color:#bf616a;">getLifecycle</span><span style="color:#eff1f5;">().</span><span style="color:#bf616a;">getCurrentState</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">// 当当前状态为DESTROYED时，移除观察者
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">if </span><span style="color:#eff1f5;">(currentState </span><span>== </span><span style="color:#d08770;">DESTROYED</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">            </span><span style="color:#bf616a;">removeObserver</span><span style="color:#eff1f5;">(mObserver);
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">Lifecycle</span><span style="color:#eff1f5;">.</span><span style="color:#ebcb8b;">State</span><span style="color:#eff1f5;"> prevState </span><span>= </span><span style="color:#d08770;">null</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">while </span><span style="color:#eff1f5;">(prevState </span><span>!=</span><span style="color:#eff1f5;"> currentState) {
</span><span style="color:#eff1f5;">            prevState </span><span>=</span><span style="color:#eff1f5;"> currentState;
</span><span style="color:#eff1f5;">            </span><span style="color:#bf616a;">activeStateChanged</span><span style="color:#eff1f5;">(</span><span style="color:#bf616a;">shouldBeActive</span><span style="color:#eff1f5;">());
</span><span style="color:#eff1f5;">            currentState </span><span>=</span><span style="color:#eff1f5;"> mOwner.</span><span style="color:#bf616a;">getLifecycle</span><span style="color:#eff1f5;">().</span><span style="color:#bf616a;">getCurrentState</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    @</span><span style="color:#bf616a;">Override
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">boolean </span><span style="color:#8fa1b3;">isAttachedTo</span><span style="color:#eff1f5;">(</span><span style="color:#ebcb8b;">LifecycleOwner </span><span style="color:#bf616a;">owner</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;"> mOwner </span><span>==</span><span style="color:#eff1f5;"> owner;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">    @</span><span style="color:#bf616a;">Override
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">detachObserver</span><span style="color:#eff1f5;">() {
</span><span style="color:#eff1f5;">        mOwner.</span><span style="color:#bf616a;">getLifecycle</span><span style="color:#eff1f5;">().</span><span style="color:#bf616a;">removeObserver</span><span style="color:#eff1f5;">(</span><span style="color:#bf616a;">this</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}
</span></code></pre>
<p>可以看到它实现了LifecycleEventObserver接口，并且重写了onStateChanged这个方法。当状态为DESTROYED时，会自动移除观察者，故而避免内存泄漏，如果不是，则会调用ObserverWrapper中的<code>activeStateChanged(shouldBeActive())</code></p>
<pre data-lang="Java" style="background-color:#2b303b;color:#c0c5ce;" class="language-Java "><code class="language-Java" data-lang="Java"><span>void </span><span style="color:#bf616a;">activeStateChanged</span><span>(</span><span style="color:#b48ead;">boolean</span><span> newActive) {
</span><span>    </span><span style="color:#b48ead;">if </span><span>(newActive == mActive) {
</span><span>        </span><span style="color:#b48ead;">return</span><span>;
</span><span>    }
</span><span>    </span><span style="color:#65737e;">// immediately set active state, so we&#39;d never dispatch anything to inactive
</span><span>    </span><span style="color:#65737e;">// owner
</span><span>    mActive = newActive;
</span><span>    </span><span style="color:#bf616a;">changeActiveCounter</span><span>(mActive ? </span><span style="color:#d08770;">1 </span><span>: -</span><span style="color:#d08770;">1</span><span>);
</span><span>    </span><span style="color:#b48ead;">if </span><span>(mActive) {
</span><span>        </span><span style="color:#bf616a;">dispatchingValue</span><span>(</span><span style="color:#bf616a;">this</span><span>);
</span><span>    }
</span><span>}
</span></code></pre>
<p>mActive是ObserverWrapper的属性，表示此观察者是否活跃，默认是false。所以，如果newActive也是false就不会去处理了，如果是活跃的，就会去出发changeActiveCounter(mActive ? 1 : -1)方法，用来改变LiveData中的mActiveCount（当前活跃观察者数量的计数器），我们主要看<code>dispatchingValue(this)</code>这个方法</p>
<pre data-lang="Java" style="background-color:#2b303b;color:#c0c5ce;" class="language-Java "><code class="language-Java" data-lang="Java"><span>@</span><span style="color:#bf616a;">SuppressWarnings</span><span>(&quot;</span><span style="color:#a3be8c;">WeakerAccess</span><span>&quot;) </span><span style="color:#65737e;">/* synthetic access */
</span><span>void </span><span style="color:#bf616a;">dispatchingValue</span><span>(@</span><span style="color:#ebcb8b;">Nullable ObserverWrapper</span><span> initiator) {
</span><span>    </span><span style="color:#65737e;">// 如果事件正在分发，则这次分发没有用，则返回
</span><span>    </span><span style="color:#b48ead;">if </span><span>(mDispatchingValue) {
</span><span>        mDispatchInvalidated = </span><span style="color:#d08770;">true</span><span>;
</span><span>        </span><span style="color:#b48ead;">return</span><span>;
</span><span>    }
</span><span>    </span><span style="color:#65737e;">// 表示正在分发
</span><span>    mDispatchingValue = </span><span style="color:#d08770;">true</span><span>;
</span><span>    </span><span style="color:#b48ead;">do </span><span>{
</span><span>        mDispatchInvalidated = </span><span style="color:#d08770;">false</span><span>;
</span><span>        </span><span style="color:#b48ead;">if </span><span>(initiator != </span><span style="color:#d08770;">null</span><span>) {
</span><span>            </span><span style="color:#bf616a;">considerNotify</span><span>(initiator);
</span><span>            initiator = </span><span style="color:#d08770;">null</span><span>;
</span><span>        } </span><span style="color:#b48ead;">else </span><span>{
</span><span>            </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#ebcb8b;">Iterator</span><span>&lt;</span><span style="color:#ebcb8b;">Map</span><span>.</span><span style="color:#ebcb8b;">Entry</span><span>&lt;</span><span style="color:#ebcb8b;">Observer</span><span>&lt;? </span><span style="color:#b48ead;">super </span><span style="color:#ebcb8b;">T</span><span>&gt;, </span><span style="color:#ebcb8b;">ObserverWrapper</span><span>&gt;&gt; iterator =
</span><span>                    mObservers.</span><span style="color:#bf616a;">iteratorWithAdditions</span><span>(); iterator.</span><span style="color:#bf616a;">hasNext</span><span>(); ) {
</span><span>                </span><span style="color:#bf616a;">considerNotify</span><span>(iterator.</span><span style="color:#bf616a;">next</span><span>().</span><span style="color:#bf616a;">getValue</span><span>());
</span><span>                </span><span style="color:#b48ead;">if </span><span>(mDispatchInvalidated) {
</span><span>                    </span><span style="color:#b48ead;">break</span><span>;
</span><span>                }
</span><span>            }
</span><span>        }
</span><span>    } </span><span style="color:#b48ead;">while </span><span>(mDispatchInvalidated);
</span><span>    mDispatchingValue = </span><span style="color:#d08770;">false</span><span>;
</span><span>}
</span></code></pre>
<p>这里存在两个boolean变量，<code>mDispatchingValue</code>和<code>mDispatchInvalidated</code>，一个用来标记当前是否在分发事件，一个表示当前分发已经无效，下次需要重新分发，然后，当我们传进来的initiator不为空时，就会去专门通知这一个观察者，调用<code>considerNotify(initiator)</code>这个方法，如果为空则会去用一个循环去通知所有观察者，这里为什么可以为空，我们先不谈，咱们先来看看<code>considerNotify(initiator)</code>这个方法。</p>
<pre data-lang="Java" style="background-color:#2b303b;color:#c0c5ce;" class="language-Java "><code class="language-Java" data-lang="Java"><span>@</span><span style="color:#bf616a;">SuppressWarnings</span><span>(&quot;</span><span style="color:#a3be8c;">unchecked</span><span>&quot;)
</span><span style="color:#b48ead;">private</span><span> void </span><span style="color:#bf616a;">considerNotify</span><span>(</span><span style="color:#ebcb8b;">ObserverWrapper</span><span> observer) {
</span><span>    </span><span style="color:#b48ead;">if </span><span>(!observer.mActive) {
</span><span>        </span><span style="color:#b48ead;">return</span><span>;
</span><span>    }
</span><span>    </span><span style="color:#65737e;">// Check latest state b4 dispatch. Maybe it changed state but we didn&#39;t get the event yet.
</span><span>    </span><span style="color:#65737e;">//
</span><span>    </span><span style="color:#65737e;">// we still first check observer.active to keep it as the entrance for events. So even if
</span><span>    </span><span style="color:#65737e;">// the observer moved to an active state, if we&#39;ve not received that event, we better not
</span><span>    </span><span style="color:#65737e;">// notify for a more predictable notification order.
</span><span>    </span><span style="color:#b48ead;">if </span><span>(!observer.</span><span style="color:#bf616a;">shouldBeActive</span><span>()) {
</span><span>        observer.</span><span style="color:#bf616a;">activeStateChanged</span><span>(</span><span style="color:#d08770;">false</span><span>);
</span><span>        </span><span style="color:#b48ead;">return</span><span>;
</span><span>    }
</span><span>    </span><span style="color:#b48ead;">if </span><span>(observer.mLastVersion &gt;= mVersion) {
</span><span>        </span><span style="color:#b48ead;">return</span><span>;
</span><span>    }
</span><span>    observer.mLastVersion = mVersion;
</span><span>    observer.mObserver.</span><span style="color:#bf616a;">onChanged</span><span>((</span><span style="color:#ebcb8b;">T</span><span>) mData);
</span><span>}
</span></code></pre>
<p>先进行检查，如果当前观察者不是活跃状态返回，否则会再次会检测一下观察者对应的owner，看其是否是活跃状态，如果不是，再次调用activeStateChanged方法，并传入false，其内部会再次判断。然后，在判断版本号，如果observer所持有的最新版本号大于等于当前的版本，则表示是最新版本，不需要分发了，否则，分发事件。</p>
<p>到这里，逻辑应该通畅了许多。我们上面提到了版本号，这是在哪里改变的呢？答案就在setValue和postValue两个数据更新的方法里</p>
<pre data-lang="typescript" style="background-color:#2b303b;color:#c0c5ce;" class="language-typescript "><code class="language-typescript" data-lang="typescript"><span>@</span><span style="color:#bf616a;">MainThread
</span><span style="color:#bf616a;">protected </span><span>void </span><span style="color:#8fa1b3;">setValue</span><span>(</span><span style="color:#bf616a;">T value</span><span>) {
</span><span>    </span><span style="color:#8fa1b3;">assertMainThread</span><span>(&quot;</span><span style="color:#a3be8c;">setValue</span><span>&quot;);
</span><span>    </span><span style="color:#bf616a;">mVersion</span><span>++;
</span><span>    </span><span style="color:#bf616a;">mData </span><span>= </span><span style="color:#bf616a;">value</span><span>;
</span><span>    </span><span style="color:#8fa1b3;">dispatchingValue</span><span>(</span><span style="color:#d08770;">null</span><span>);
</span><span>}
</span><span>
</span><span style="color:#bf616a;">protected </span><span>void </span><span style="color:#8fa1b3;">postValue</span><span>(</span><span style="color:#bf616a;">T value</span><span>) {
</span><span>    </span><span style="color:#bf616a;">boolean postTask</span><span>;
</span><span>    </span><span style="color:#8fa1b3;">synchronized </span><span>(</span><span style="color:#bf616a;">mDataLock</span><span>) {
</span><span>        </span><span style="color:#bf616a;">postTask </span><span>= </span><span style="color:#bf616a;">mPendingData </span><span>== </span><span style="color:#bf616a;">NOT_SET</span><span>;
</span><span>        </span><span style="color:#bf616a;">mPendingData </span><span>= </span><span style="color:#bf616a;">value</span><span>;
</span><span>    }
</span><span>    </span><span style="color:#b48ead;">if </span><span>(!</span><span style="color:#bf616a;">postTask</span><span>) {
</span><span>        </span><span style="color:#b48ead;">return</span><span>;
</span><span>    }
</span><span>    </span><span style="color:#65737e;">//抛到主线程
</span><span>    </span><span style="color:#bf616a;">ArchTaskExecutor</span><span>.</span><span style="color:#8fa1b3;">getInstance</span><span>().</span><span style="color:#8fa1b3;">postToMainThread</span><span>(</span><span style="color:#bf616a;">mPostValueRunnable</span><span>);
</span><span>}
</span><span style="color:#bf616a;">private final Runnable mPostValueRunnable </span><span>= new Runnable() {
</span><span>    @</span><span style="color:#8fa1b3;">SuppressWarnings</span><span>(&quot;</span><span style="color:#a3be8c;">unchecked</span><span>&quot;)
</span><span>    @</span><span style="color:#bf616a;">Override
</span><span>    </span><span style="color:#bf616a;">public </span><span>void </span><span style="color:#8fa1b3;">run</span><span>() {
</span><span>        </span><span style="color:#ebcb8b;">Object </span><span style="color:#bf616a;">newValue</span><span>;
</span><span>        </span><span style="color:#8fa1b3;">synchronized </span><span>(</span><span style="color:#bf616a;">mDataLock</span><span>) {
</span><span>            </span><span style="color:#bf616a;">newValue </span><span>= </span><span style="color:#bf616a;">mPendingData</span><span>;
</span><span>            </span><span style="color:#bf616a;">mPendingData </span><span>= </span><span style="color:#bf616a;">NOT_SET</span><span>;
</span><span>        }
</span><span>        </span><span style="color:#8fa1b3;">setValue</span><span>((</span><span style="color:#bf616a;">T</span><span>) </span><span style="color:#bf616a;">newValue</span><span>);
</span><span>    }
</span><span>};
</span></code></pre>
<p>可以看到在setValue方法中有一个<code>mVersion++</code>，然后调用了<code>dispatchingValue(null)</code>方法，及上面提到的空的情况，所以一切都明了了。而postValue一样最后会调用setValue方法，只不过它用于在子线程中更新数据。</p>
<p>到这，关于LiveData的源码分析就到这，简单来说，就是LivaData通过observe()添加与LifecycleOwner绑定的观察者；观察者变为活跃时回调最新的数据；使用setValue()、postValue()更新数据时会通知回调所有的观察者。</p>
<h1 id="viewmodel">ViewModel</h1>
<h2 id="shen-me-shi-viewmodel">什么是ViewModel？</h2>
<p>ViewModel，意为 视图模型，即 <strong>为界面准备数据的模型</strong>。</p>
<p>简单理解就是，ViewModel是一个为UI层提供数据的东西。</p>
<h2 id="viewmodelchu-xian-de-bei-jing">ViewModel出现的背景</h2>
<p>当我们的activity或fragment发生意外重构了（如屏幕旋转等），我们数据还会有吗？</p>
<p>答案是否定的，这个时候，viewmodel就发挥出用处了，原因就在于viewmodel的生命周期比activity的更长。</p>
<p><img src="https://redrock.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmE5OTE5OTliNTc2Zjk4MjZmNWI2NjA0NjdiNDkwZDRfamlVSUV5UUliT0JyelFsazFxUnpGa1lCNW5xYkkxU0pfVG9rZW46VEZ0ZmJ1VVlUb0lJTlR4aUhMaWNQMEVIbnN6XzE3NDcyMDE5OTE6MTc0NzIwNTU5MV9WNA" alt="img" /></p>
<h2 id="viewmodelde-shi-yong">ViewModel的使用</h2>
<h3 id="chuang-jian-viewmodel">创建ViewModel</h3>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">TestViewmodel </span><span>: </span><span style="color:#a3be8c;">ViewModel</span><span>() {
</span><span>    </span><span style="color:#b48ead;">private val </span><span>_data = MutableLiveData&lt;</span><span style="color:#b48ead;">String</span><span>&gt;()
</span><span>    </span><span style="color:#b48ead;">val </span><span>data: LiveData&lt;</span><span style="color:#b48ead;">String</span><span>&gt;
</span><span>        </span><span style="color:#8fa1b3;">get</span><span>() = _data
</span><span>
</span><span>    </span><span style="color:#b48ead;">fun </span><span style="color:#8fa1b3;">getData</span><span>() {
</span><span>        _data.value = &quot;</span><span style="color:#a3be8c;">获取到了数据</span><span>&quot;
</span><span>    }
</span><span>}
</span></code></pre>
<p>一般来说，我们不应该将MutableLiveData暴露给activity，而是在viewmodel里去修改数据，然后将其转化为LiveData传给activity。</p>
<h3 id="activityhuo-qu-viewmodel">activity获取viewmodel</h3>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">ViewModelActivity </span><span>: </span><span style="color:#a3be8c;">AppCompatActivity</span><span>() {
</span><span>
</span><span>    </span><span style="color:#b48ead;">private val </span><span>binding </span><span style="color:#b48ead;">by</span><span> lazy { ActivityViewmodelBinding.inflate(layoutInflater) }
</span><span>    </span><span style="color:#b48ead;">private val </span><span>mViewModel </span><span style="color:#b48ead;">by</span><span> lazy {
</span><span>        ViewModelProvider(</span><span style="color:#d08770;">this</span><span>)[TestViewmodel::class.java]
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onCreate</span><span>(savedInstanceState: Bundle?) {
</span><span>        </span><span style="color:#d08770;">super</span><span>.onCreate(savedInstanceState)
</span><span>        enableEdgeToEdge()
</span><span>        setContentView(binding.root)
</span><span>        binding.btn.setOnClickListener {
</span><span>            mViewModel.getData()
</span><span>        }
</span><span>        </span><span style="color:#65737e;">// 观察
</span><span>        mViewModel.</span><span style="color:#b48ead;">data</span><span>.observe(</span><span style="color:#d08770;">this</span><span>) {
</span><span>            binding.tv.text = it
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>这里我们用了个ViewModelProvider，传了个Lifecycleowner进去，然后把我们的ViewModel写了进去。</p>
<p>然后通过点击事件，执行我们viewmodel里面的getData方法，然后观察完事！</p>
<p>当然，还提供了其他的创建方式</p>
<p>导入依赖</p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span style="color:#65737e;">// activity
</span><span>implementation(&quot;</span><span style="color:#a3be8c;">androidx.activity:activity-ktx:1.10.1</span><span>&quot;)
</span><span style="color:#65737e;">// fragment
</span><span>implementation(&quot;</span><span style="color:#a3be8c;">androidx.fragment:fragment-ktx:1.8.6</span><span>&quot;)
</span></code></pre>
<p>然后就可以用下面的方式创建</p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span style="color:#b48ead;">private val </span><span>mViewModel </span><span style="color:#b48ead;">by</span><span> viewModels&lt;TestViewmodel&gt;()
</span></code></pre>
<h2 id="viewmodelde-yuan-li">ViewModel的原理</h2>
<p>为什么当activity/fragment重建后，viewmodel还可以存在呢？</p>
<p>我们从<code>ViewModelProvider(this)[TestViewmodel::class.java]</code>下手，ViewModelProvider由名可知Viewmodel的提供者，我们来看看它的构造方法</p>
<pre data-lang="Kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-Kotlin "><code class="language-Kotlin" data-lang="Kotlin"><span style="color:#b48ead;">public</span><span> constructor(
</span><span>    owner: ViewModelStoreOwner
</span><span>) : </span><span style="color:#d08770;">this</span><span>(owner.viewModelStore, defaultFactory(owner), defaultCreationExtras(owner))
</span><span>
</span><span style="color:#b48ead;">public</span><span> constructor(owner: ViewModelStoreOwner, factory: Factory) : </span><span style="color:#d08770;">this</span><span>(
</span><span>    owner.viewModelStore,
</span><span>    factory,
</span><span>    defaultCreationExtras(owner)
</span><span>)
</span></code></pre>
<p>介绍一下各个类</p>
<ul>
<li><code>ViewModelStoreOwner</code>：ViewModel存储器拥有者</li>
<li><code>ViewModelStore</code>：ViewModel存储器</li>
<li><code>Factory</code>：创造ViewModel实例的工厂</li>
</ul>
<p>我们先来看看ViewModelStoreOwner:</p>
<pre data-lang="Kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-Kotlin "><code class="language-Kotlin" data-lang="Kotlin"><span style="color:#b48ead;">interface </span><span style="color:#ebcb8b;">ViewModelStoreOwner</span><span> {
</span><span>
</span><span>    </span><span style="color:#65737e;">/**
</span><span style="color:#65737e;">     * The owned [ViewModelStore]
</span><span style="color:#65737e;">     */
</span><span>    </span><span style="color:#b48ead;">val </span><span>viewModelStore: ViewModelStore
</span><span>}
</span></code></pre>
<p>可以看到其是一个接口，我们的Activity和Fragment都实现了这个接口，都是ViewModel存储器拥有者，我们先不管他们是咋获取到ViewModelStore的，我们先来看看ViewModelStore是咋存储Viewmodel的</p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span style="color:#b48ead;">open class </span><span style="color:#ebcb8b;">ViewModelStore</span><span> {
</span><span>
</span><span>    </span><span style="color:#b48ead;">private val </span><span>map = mutableMapOf&lt;</span><span style="color:#b48ead;">String</span><span>, ViewModel&gt;()
</span><span>
</span><span>    @RestrictTo(RestrictTo.Scope.</span><span style="color:#d08770;">LIBRARY_GROUP</span><span>)
</span><span>    </span><span style="color:#b48ead;">fun </span><span style="color:#8fa1b3;">put</span><span>(key: </span><span style="color:#b48ead;">String</span><span>, viewModel: ViewModel) {
</span><span>        </span><span style="color:#b48ead;">val </span><span>oldViewModel = map.put(key, viewModel)
</span><span>        oldViewModel?.onCleared()
</span><span>    }
</span><span>
</span><span>    @RestrictTo(RestrictTo.Scope.</span><span style="color:#d08770;">LIBRARY_GROUP</span><span>)
</span><span>    </span><span style="color:#b48ead;">operator fun </span><span style="color:#8fa1b3;">get</span><span>(key: </span><span style="color:#b48ead;">String</span><span>): ViewModel? {
</span><span>        </span><span style="color:#b48ead;">return</span><span> map[key]
</span><span>    }
</span><span>
</span><span>    @RestrictTo(RestrictTo.Scope.</span><span style="color:#d08770;">LIBRARY_GROUP</span><span>)
</span><span>    </span><span style="color:#b48ead;">fun </span><span style="color:#8fa1b3;">keys</span><span>(): </span><span style="color:#b48ead;">Set</span><span>&lt;</span><span style="color:#b48ead;">String</span><span>&gt; {
</span><span>        </span><span style="color:#b48ead;">return</span><span> HashSet(map.keys)
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">fun </span><span style="color:#8fa1b3;">clear</span><span>() {
</span><span>        </span><span style="color:#b48ead;">for</span><span> (vm </span><span style="color:#b48ead;">in</span><span> map.values) {
</span><span>            vm.clear()
</span><span>        }
</span><span>        map.clear()
</span><span>    }
</span><span>}
</span></code></pre>
<p>可以看到，内部还是比较清晰的，viewModel作为Value存储在map中</p>
<p>我们再来看看Factory是咋生产ViewModel的</p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span style="color:#b48ead;">public interface </span><span style="color:#ebcb8b;">Factory</span><span> {
</span><span>
</span><span>    </span><span style="color:#b48ead;">public fun</span><span> &lt;</span><span style="color:#b48ead;">T </span><span>: ViewModel&gt; </span><span style="color:#8fa1b3;">create</span><span>(modelClass: Class&lt;T&gt;): T {
</span><span>        </span><span style="color:#b48ead;">throw</span><span> UnsupportedOperationException(
</span><span>            &quot;</span><span style="color:#a3be8c;">Factory.create(String) is unsupported.  This Factory requires </span><span>&quot; +
</span><span>                &quot;</span><span style="color:#a3be8c;">`CreationExtras` to be passed into `create` method.</span><span>&quot;
</span><span>        )
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">public fun</span><span> &lt;</span><span style="color:#b48ead;">T </span><span>: ViewModel&gt; </span><span style="color:#8fa1b3;">create</span><span>(modelClass: Class&lt;T&gt;, extras: CreationExtras): T =
</span><span>        create(modelClass)
</span><span>
</span><span>    </span><span style="color:#b48ead;">companion object</span><span> {
</span><span>        @JvmStatic
</span><span>        </span><span style="color:#b48ead;">fun </span><span style="color:#8fa1b3;">from</span><span>(</span><span style="color:#b48ead;">vararg </span><span>initializers: ViewModelInitializer&lt;*&gt;): Factory =
</span><span>            InitializerViewModelFactory(*initializers)
</span><span>    }
</span><span>}
</span></code></pre>
<p>可以看到它是一个接口，而我们的实现类是<code>NewInstanceFactory</code></p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span>@Suppress(&quot;</span><span style="color:#a3be8c;">SingletonConstructor</span><span>&quot;)
</span><span style="color:#b48ead;">public open class </span><span style="color:#ebcb8b;">NewInstanceFactory </span><span>: </span><span style="color:#a3be8c;">Factory</span><span> {
</span><span>    @Suppress(&quot;</span><span style="color:#a3be8c;">DocumentExceptions</span><span>&quot;)
</span><span>    </span><span style="color:#b48ead;">override fun</span><span> &lt;</span><span style="color:#b48ead;">T </span><span>: ViewModel&gt; </span><span style="color:#8fa1b3;">create</span><span>(modelClass: Class&lt;T&gt;): T {
</span><span>        </span><span style="color:#b48ead;">return try</span><span> {
</span><span>            modelClass.getDeclaredConstructor().newInstance()
</span><span>        } </span><span style="color:#b48ead;">catch</span><span> (e: NoSuchMethodException) {
</span><span>            </span><span style="color:#b48ead;">throw</span><span> RuntimeException(&quot;</span><span style="color:#a3be8c;">Cannot create an instance of </span><span style="color:#bf616a;">$modelClass</span><span>&quot;, e)
</span><span>        } </span><span style="color:#b48ead;">catch</span><span> (e: InstantiationException) {
</span><span>            </span><span style="color:#b48ead;">throw</span><span> RuntimeException(&quot;</span><span style="color:#a3be8c;">Cannot create an instance of </span><span style="color:#bf616a;">$modelClass</span><span>&quot;, e)
</span><span>        } </span><span style="color:#b48ead;">catch</span><span> (e: IllegalAccessException) {
</span><span>            </span><span style="color:#b48ead;">throw</span><span> RuntimeException(&quot;</span><span style="color:#a3be8c;">Cannot create an instance of </span><span style="color:#bf616a;">$modelClass</span><span>&quot;, e)
</span><span>        }
</span><span>    }
</span><span>    ...
</span><span>}
</span></code></pre>
<p>这边利用了反射机制，将传入的class通过反射获取Viewmodel.</p>
<blockquote>
<p>反射是 Java 中的一个特性，它允许程序在运行时获取自身的信息，并动态地操作类或对象的属性、方法和构造函数。通过反射，我们可以在事先不知道确切类名的情况下实例化对象、调用方法和设置属性。</p>
</blockquote>
<p>我们再来看看<code>ViewModelProvider(this)[TestViewmodel::class.java]</code>的中括号是什么，其实是一个get方法，这里用到了kotlin中的语法糖，重载了 <code>operator fun get()</code>，这样可以使用中括号代替get方法，我们来看看这个get方法</p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span>@MainThread
</span><span style="color:#b48ead;">public open operator fun</span><span> &lt;</span><span style="color:#b48ead;">T </span><span>: ViewModel&gt; </span><span style="color:#8fa1b3;">get</span><span>(modelClass: Class&lt;T&gt;): T {
</span><span>    </span><span style="color:#b48ead;">val </span><span>canonicalName = modelClass.canonicalName
</span><span>        ?: </span><span style="color:#b48ead;">throw</span><span> IllegalArgumentException(&quot;</span><span style="color:#a3be8c;">Local and anonymous classes can not be ViewModels</span><span>&quot;)
</span><span>    </span><span style="color:#b48ead;">return</span><span> get(&quot;</span><span style="color:#bf616a;">$DEFAULT_KEY</span><span style="color:#a3be8c;">:</span><span style="color:#bf616a;">$canonicalName</span><span>&quot;, modelClass)
</span><span>}
</span><span>
</span><span>@Suppress(&quot;</span><span style="color:#a3be8c;">UNCHECKED_CAST</span><span>&quot;)
</span><span>@MainThread
</span><span style="color:#b48ead;">public open operator fun</span><span> &lt;</span><span style="color:#b48ead;">T </span><span>: ViewModel&gt; </span><span style="color:#8fa1b3;">get</span><span>(key: </span><span style="color:#b48ead;">String</span><span>, modelClass: Class&lt;T&gt;): T {
</span><span>    </span><span style="color:#b48ead;">val </span><span>viewModel = store[key]
</span><span>    </span><span style="color:#b48ead;">if</span><span> (modelClass.isInstance(viewModel)) {
</span><span>        (factory as? OnRequeryFactory)?.onRequery(viewModel!!)
</span><span>        </span><span style="color:#b48ead;">return</span><span> viewModel as T
</span><span>    } </span><span style="color:#b48ead;">else</span><span> {
</span><span>        @Suppress(&quot;</span><span style="color:#a3be8c;">ControlFlowWithEmptyBody</span><span>&quot;)
</span><span>        </span><span style="color:#b48ead;">if</span><span> (viewModel != </span><span style="color:#d08770;">null</span><span>) {
</span><span>            </span><span style="color:#65737e;">// TODO: log a warning.
</span><span>        }
</span><span>    }
</span><span>    </span><span style="color:#b48ead;">val </span><span>extras = MutableCreationExtras(defaultCreationExtras)
</span><span>    extras[</span><span style="color:#d08770;">VIEW_MODEL_KEY</span><span>] = key
</span><span>    </span><span style="color:#65737e;">// AGP has some desugaring issues associated with compileOnly dependencies so we need to
</span><span>    </span><span style="color:#65737e;">// fall back to the other create method to keep from crashing.
</span><span>    </span><span style="color:#b48ead;">return try</span><span> {
</span><span>        factory.create(modelClass, extras)
</span><span>    } </span><span style="color:#b48ead;">catch</span><span> (e: AbstractMethodError) {
</span><span>        factory.create(modelClass)
</span><span>    }.also { store.put(key, it) }
</span><span>}
</span></code></pre>
<p>应该挺好知道的，就是将viewmodel从我们的ViewModelStore中取出来，如果没有，就会去用factory创造出来，然后再存入store里面。</p>
<p>ok，现在我们知道了Viewmodel是怎么被存储的，怎么被创造的，接下来就来聊聊我们一开始的那个问题，为什么viewmodel再activity/fragment异常重建后不会消失。</p>
<p>我们来看看activity/fragment是咋从获取到ViewmodelStore，</p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span style="color:#b48ead;">override val </span><span>viewModelStore: ViewModelStore
</span><span>    </span><span style="color:#8fa1b3;">get</span><span>() {
</span><span>        </span><span style="color:#65737e;">// activity还没关联Application，即不能在onCreate之前去获取viewModel
</span><span>        checkNotNull(application) {
</span><span>            (&quot;</span><span style="color:#a3be8c;">Your activity is not yet attached to the </span><span>&quot; +
</span><span>                &quot;</span><span style="color:#a3be8c;">Application instance. You can&#39;t request ViewModel before onCreate call.</span><span>&quot;)
</span><span>        }
</span><span>        ensureViewModelStore()
</span><span>        </span><span style="color:#b48ead;">return</span><span> _viewModelStore!!
</span><span>    }
</span><span>
</span><span style="color:#b48ead;">private fun </span><span style="color:#8fa1b3;">ensureViewModelStore</span><span>() {
</span><span>    </span><span style="color:#b48ead;">if</span><span> (_viewModelStore == </span><span style="color:#d08770;">null</span><span>) {
</span><span>        </span><span style="color:#b48ead;">val </span><span>nc = lastNonConfigurationInstance as NonConfigurationInstances?
</span><span>        </span><span style="color:#b48ead;">if</span><span> (nc != </span><span style="color:#d08770;">null</span><span>) {
</span><span>            </span><span style="color:#65737e;">// Restore the ViewModelStore from NonConfigurationInstances
</span><span>            _viewModelStore = nc.viewModelStore
</span><span>        }
</span><span>        </span><span style="color:#b48ead;">if</span><span> (_viewModelStore == </span><span style="color:#d08770;">null</span><span>) {
</span><span>            _viewModelStore = ViewModelStore()
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>可以看到如果_viewModelStore为空的话，会从NonConfigurationInstance中获取我们的viewModelStore，如果它里面没有，就会重新定义一个ViewModelStore，那这个NonConfigurationInstance是个啥呢？翻译过来:<strong>非配置实例</strong>,即与系统配置无关的实例。所以屏幕旋转等的配置改变不会影响到这个实例,它是Android官方提供给因配置改变而要保存的数据的。activity中有个onRetainCustomNonConfigurationInstance方法，他会在onStop和onDeatory的时候会在onRetainCustomNonConfigurationInstance中保存的自定义非配置实例</p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span>@Suppress(&quot;</span><span style="color:#a3be8c;">deprecation</span><span>&quot;)
</span><span style="color:#b48ead;">final override fun </span><span style="color:#8fa1b3;">onRetainNonConfigurationInstance</span><span>(): </span><span style="color:#b48ead;">Any</span><span>? {
</span><span>    </span><span style="color:#65737e;">// Maintain backward compatibility.
</span><span>    </span><span style="color:#b48ead;">val </span><span>custom = onRetainCustomNonConfigurationInstance()
</span><span>    </span><span style="color:#b48ead;">var </span><span>viewModelStore = _viewModelStore
</span><span>    </span><span style="color:#b48ead;">if</span><span> (viewModelStore == </span><span style="color:#d08770;">null</span><span>) {
</span><span>        </span><span style="color:#65737e;">// No one called getViewModelStore(), so see if there was an existing
</span><span>        </span><span style="color:#65737e;">// ViewModelStore from our last NonConfigurationInstance
</span><span>        </span><span style="color:#b48ead;">val </span><span>nc = lastNonConfigurationInstance as NonConfigurationInstances?
</span><span>        </span><span style="color:#b48ead;">if</span><span> (nc != </span><span style="color:#d08770;">null</span><span>) {
</span><span>            viewModelStore = nc.viewModelStore
</span><span>        }
</span><span>    }
</span><span>    </span><span style="color:#b48ead;">if</span><span> (viewModelStore == </span><span style="color:#d08770;">null </span><span>&amp;&amp; custom == </span><span style="color:#d08770;">null</span><span>) {
</span><span>        </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">null
</span><span>    }
</span><span>    </span><span style="color:#b48ead;">val </span><span>nci = NonConfigurationInstances()
</span><span>    nci.custom = custom
</span><span>    nci.viewModelStore = viewModelStore
</span><span>    </span><span style="color:#b48ead;">return</span><span> nci
</span><span>}
</span></code></pre>
<p>我们就是利用这里去保存我们的ViewmodelStore。</p>
<h1 id="viewbinding">ViewBinding</h1>
<h2 id="cong-shou-xie-findviewbyid-dao-viewbinding">从 手写<code>findViewById</code> 到 ViewBinding</h2>
<p>如标题所示，ViewBinding的用处就是为了代替<code>findViewById</code>，部分与UI控件相关的代码可以在布局文件中完成。使用 ViewBinding后，不再需要findViewById()方法。</p>
<h2 id="viewbindingde-shi-yong">ViewBinding的使用</h2>
<ol>
<li>启用Viewbinding，在app模块目录下 <strong><code>build.gradle</code></strong> 添加下述配置：</li>
</ol>
<pre data-lang="Groovy" style="background-color:#2b303b;color:#c0c5ce;" class="language-Groovy "><code class="language-Groovy" data-lang="Groovy"><span>android {
</span><span>    ...
</span><span>    viewBinding{
</span><span>        enable = </span><span style="color:#d08770;">true
</span><span>    }
</span><span>    </span><span style="color:#65737e;">// 或者
</span><span>    buildFeatures{
</span><span>        viewBinding = </span><span style="color:#d08770;">true
</span><span>    }
</span><span>}
</span></code></pre>
<p>配置过后，我们的每一个layout文件都会生成一个对应的绑定类，该绑定类的命名就是 layou 文件的名称转换为驼峰形式，并在末尾添加 Binding 一词。以 activity_main.xml 为例，其对应的绑定类名称为 ActivityMainBinding。</p>
<p>上面说了会为每个layout文件都生成一个绑定类，如果该布局文件不需要的话，可以使用 <code>tools:viewBinding-Ignore</code> 属性来设置</p>
<pre data-lang="xml" style="background-color:#2b303b;color:#c0c5ce;" class="language-xml "><code class="language-xml" data-lang="xml"><span>&lt;?</span><span style="color:#bf616a;">xml </span><span style="color:#d08770;">version</span><span>=&quot;</span><span style="color:#a3be8c;">1.0</span><span>&quot; </span><span style="color:#d08770;">encoding</span><span>=&quot;</span><span style="color:#a3be8c;">utf-8</span><span>&quot;?&gt;
</span><span>&lt;</span><span style="color:#bf616a;">androidx.constraintlayout.widget.ConstraintLayout </span><span style="color:#d08770;">xmlns:android</span><span>=&quot;</span><span style="color:#a3be8c;">http://schemas.android.com/apk/res/android</span><span>&quot;
</span><span>    </span><span style="color:#d08770;">xmlns:tools</span><span>=&quot;</span><span style="color:#a3be8c;">http://schemas.android.com/tools</span><span>&quot;
</span><span>    </span><span style="color:#d08770;">tools:viewBinding-Ignore</span><span>=&quot;</span><span style="color:#a3be8c;">true</span><span>&quot;
</span><span>    </span><span style="color:#d08770;">android:layout_width</span><span>=&quot;</span><span style="color:#a3be8c;">match_parent</span><span>&quot;
</span><span>    </span><span style="color:#d08770;">android:layout_height</span><span>=&quot;</span><span style="color:#a3be8c;">match_parent</span><span>&quot;&gt;
</span><span>
</span><span>&lt;/</span><span style="color:#bf616a;">androidx.constraintlayout.widget.ConstraintLayout</span><span>&gt;
</span></code></pre>
<ol>
<li>在Activity中使用ViewBinding</li>
</ol>
<p>activity_main.xml</p>
<pre data-lang="xml" style="background-color:#2b303b;color:#c0c5ce;" class="language-xml "><code class="language-xml" data-lang="xml"><span>&lt;?</span><span style="color:#bf616a;">xml </span><span style="color:#d08770;">version</span><span>=&quot;</span><span style="color:#a3be8c;">1.0</span><span>&quot; </span><span style="color:#d08770;">encoding</span><span>=&quot;</span><span style="color:#a3be8c;">utf-8</span><span>&quot;?&gt;
</span><span>&lt;</span><span style="color:#bf616a;">androidx.constraintlayout.widget.ConstraintLayout </span><span style="color:#d08770;">xmlns:android</span><span>=&quot;</span><span style="color:#a3be8c;">http://schemas.android.com/apk/res/android</span><span>&quot;
</span><span>    </span><span style="color:#d08770;">xmlns:app</span><span>=&quot;</span><span style="color:#a3be8c;">http://schemas.android.com/apk/res-auto</span><span>&quot;
</span><span>    </span><span style="color:#d08770;">android:id</span><span>=&quot;</span><span style="color:#a3be8c;">@+id/main</span><span>&quot;
</span><span>    </span><span style="color:#d08770;">android:layout_width</span><span>=&quot;</span><span style="color:#a3be8c;">match_parent</span><span>&quot;
</span><span>    </span><span style="color:#d08770;">android:layout_height</span><span>=&quot;</span><span style="color:#a3be8c;">match_parent</span><span>&quot;&gt;
</span><span>
</span><span>    &lt;</span><span style="color:#bf616a;">TextView
</span><span>        </span><span style="color:#d08770;">android:id</span><span>=&quot;</span><span style="color:#a3be8c;">@+id/tv_main</span><span>&quot;
</span><span>        </span><span style="color:#d08770;">android:layout_width</span><span>=&quot;</span><span style="color:#a3be8c;">wrap_content</span><span>&quot;
</span><span>        </span><span style="color:#d08770;">android:layout_height</span><span>=&quot;</span><span style="color:#a3be8c;">wrap_content</span><span>&quot;
</span><span>        </span><span style="color:#d08770;">android:text</span><span>=&quot;</span><span style="color:#a3be8c;">这是个文本</span><span>&quot;
</span><span>        </span><span style="color:#d08770;">app:layout_constraintBottom_toBottomOf</span><span>=&quot;</span><span style="color:#a3be8c;">parent</span><span>&quot;
</span><span>        </span><span style="color:#d08770;">app:layout_constraintEnd_toEndOf</span><span>=&quot;</span><span style="color:#a3be8c;">parent</span><span>&quot;
</span><span>        </span><span style="color:#d08770;">app:layout_constraintStart_toStartOf</span><span>=&quot;</span><span style="color:#a3be8c;">parent</span><span>&quot;
</span><span>        </span><span style="color:#d08770;">app:layout_constraintTop_toTopOf</span><span>=&quot;</span><span style="color:#a3be8c;">parent</span><span>&quot; /&gt;
</span><span>
</span><span>&lt;/</span><span style="color:#bf616a;">androidx.constraintlayout.widget.ConstraintLayout</span><span>&gt;
</span></code></pre>
<p>MainActivity中</p>
<pre data-lang="Kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-Kotlin "><code class="language-Kotlin" data-lang="Kotlin"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">MainActivity </span><span>: </span><span style="color:#a3be8c;">AppCompatActivity</span><span>() {
</span><span>
</span><span>    </span><span style="color:#65737e;">// 首先声明变量
</span><span>    </span><span style="color:#b48ead;">private</span><span> lateinit </span><span style="color:#b48ead;">var </span><span>binding: ActivityMainBinding
</span><span>    
</span><span>    </span><span style="color:#65737e;">// 或者使用懒加载
</span><span>    </span><span style="color:#b48ead;">private val </span><span>binding </span><span style="color:#b48ead;">by</span><span> lazy {
</span><span>        ActivityMainBinding.inflate(layoutInflater)
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onCreate</span><span>(savedInstanceState: Bundle?) {
</span><span>        </span><span style="color:#d08770;">super</span><span>.onCreate(savedInstanceState)
</span><span>        enableEdgeToEdge()
</span><span>        </span><span style="color:#65737e;">// 通过生成的binding去加载布局
</span><span>        binding = ActivityMainBinding.inflate(layoutInflater)
</span><span>        </span><span style="color:#65737e;">// 调用binding的getRoot()可以得到activity_main.xml的根布局
</span><span>        setContentView(binding.root)
</span><span>        
</span><span>        </span><span style="color:#65737e;">// 使用binding实例获取到控件
</span><span>        binding.tvMain.setOnClickListener {
</span><span>            binding.tvMain.text = &quot;</span><span style="color:#a3be8c;">我被点击了</span><span>&quot;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<h1 id="databinding">DataBinding</h1>
<p>ok，聊完了ViewBinding，我们来聊聊DataBinding</p>
<h2 id="shen-me-shi-databinding">什么是DataBinding？</h2>
<p>前面提到的ViewBinding其实可以看作是DataBinding的子集，他的功能基本上DataBinding都有，而且DataBinding还多了数据绑定的功能。</p>
<p>什么意思呢？举个简单例子</p>
<blockquote>
<p>有一个计数器功能，有个变量num，一个显示的TextView，二者绑定，当num变化时，TextView自动刷新，不需我们手动setText了。</p>
</blockquote>
<p>上面这种叫单向绑定，还有一种双向绑定，就是视图发生改变会使得数据源也发生变化。</p>
<h2 id="databindingyong-fa">Databinding用法</h2>
<p>与ViewBinding一样，先启用</p>
<p>在app模块目录下 <strong><code>build.gradle</code></strong> 添加下述配置：</p>
<pre data-lang="Groovy" style="background-color:#2b303b;color:#c0c5ce;" class="language-Groovy "><code class="language-Groovy" data-lang="Groovy"><span>android {
</span><span>    ...
</span><span>    dataBinding {
</span><span>        enable = </span><span style="color:#d08770;">true
</span><span>    }
</span><span>    </span><span style="color:#65737e;">// 二选一即可
</span><span>    buildFeatures {
</span><span>        dataBinding = </span><span style="color:#d08770;">true
</span><span>    }
</span><span>}
</span></code></pre>
<p>写一个计数器的例子</p>
<p>activity中</p>
<pre data-lang="Kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-Kotlin "><code class="language-Kotlin" data-lang="Kotlin"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">DatabindingActivity </span><span>: </span><span style="color:#a3be8c;">AppCompatActivity</span><span>() {
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onCreate</span><span>(savedInstanceState: Bundle?) {
</span><span>        </span><span style="color:#d08770;">super</span><span>.onCreate(savedInstanceState)
</span><span>        enableEdgeToEdge()
</span><span>        setContentView(R.layout.activity_databinding)
</span><span>        </span><span style="color:#b48ead;">var </span><span>num = </span><span style="color:#d08770;">0
</span><span>        </span><span style="color:#b48ead;">val </span><span>tv = findViewById&lt;TextView&gt;(R.id.tv_databinding)
</span><span>        
</span><span>        findViewById&lt;Button&gt;(R.id.bt_databinding).setOnClickListener { 
</span><span>            tv.text = &quot;</span><span style="color:#a3be8c;">计数器：</span><span style="color:#bf616a;">${++num}</span><span>&quot;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>这是我们普通写法。</p>
<p>使用DataBinding</p>
<ol>
<li>来到layout文件，将鼠标放到根布局上，按Alt和Enter键，点击**<code>Convert to data binding layout</code>**</li>
</ol>
<p><img src="https://redrock.feishu.cn/space/api/box/stream/download/asynccode/?code=MjIxM2E3YjE5Mjc3OWNlYzQyODQ3MmEzZDJlYzNlMDVfVkU0TXVqQ3c2WEpiRDFic0ZRd1NVMXlvRlRHaDlxSWJfVG9rZW46UEJCTWJVaGJBb2pvc0p4QThramNISWt5bkNiXzE3NDcyMDE5OTE6MTc0NzIwNTU5MV9WNA" alt="img" /></p>
<p>生成之后的文件</p>
<p><img src="https://redrock.feishu.cn/space/api/box/stream/download/asynccode/?code=YmZjZmIxMDQ5MGZiMTIwZGJjNmEzNjk2OGRlODdjZTBfZzBDeVp5R25LUFdZVjJkbHd3M3RmdlFHUTJvNDZzVVBfVG9rZW46RUt5QmJ0MmU2b3h6ZWp4amtra2M2dGdQbmpiXzE3NDcyMDE5OTE6MTc0NzIwNTU5MV9WNA" alt="img" /></p>
<p>接下来，在data标签中添加属性，并将TextView指向该属性</p>
<pre data-lang="xml" style="background-color:#2b303b;color:#c0c5ce;" class="language-xml "><code class="language-xml" data-lang="xml"><span>&lt;?</span><span style="color:#bf616a;">xml </span><span style="color:#d08770;">version</span><span>=&quot;</span><span style="color:#a3be8c;">1.0</span><span>&quot; </span><span style="color:#d08770;">encoding</span><span>=&quot;</span><span style="color:#a3be8c;">utf-8</span><span>&quot;?&gt;
</span><span>&lt;</span><span style="color:#bf616a;">layout </span><span style="color:#d08770;">xmlns:android</span><span>=&quot;</span><span style="color:#a3be8c;">http://schemas.android.com/apk/res/android</span><span>&quot;&gt;
</span><span>
</span><span>    &lt;</span><span style="color:#bf616a;">data</span><span>&gt;
</span><span>        &lt;</span><span style="color:#bf616a;">variable
</span><span>            </span><span style="color:#d08770;">name</span><span>=&quot;</span><span style="color:#a3be8c;">mNum</span><span>&quot;
</span><span>            </span><span style="color:#d08770;">type</span><span>=&quot;</span><span style="color:#a3be8c;">int</span><span>&quot; /&gt;
</span><span>    &lt;/</span><span style="color:#bf616a;">data</span><span>&gt;
</span><span>
</span><span>    &lt;</span><span style="color:#bf616a;">LinearLayout
</span><span>        </span><span style="color:#d08770;">android:layout_width</span><span>=&quot;</span><span style="color:#a3be8c;">match_parent</span><span>&quot;
</span><span>        </span><span style="color:#d08770;">android:layout_height</span><span>=&quot;</span><span style="color:#a3be8c;">match_parent</span><span>&quot;
</span><span>        </span><span style="color:#d08770;">android:orientation</span><span>=&quot;</span><span style="color:#a3be8c;">vertical</span><span>&quot;&gt;
</span><span>
</span><span>        &lt;</span><span style="color:#bf616a;">TextView
</span><span>            </span><span style="color:#d08770;">android:id</span><span>=&quot;</span><span style="color:#a3be8c;">@+id/tv_databinding</span><span>&quot;
</span><span>            </span><span style="color:#d08770;">android:layout_width</span><span>=&quot;</span><span style="color:#a3be8c;">match_parent</span><span>&quot;
</span><span>            </span><span style="color:#d08770;">android:layout_height</span><span>=&quot;</span><span style="color:#a3be8c;">48dp</span><span>&quot;
</span><span>            </span><span style="color:#d08770;">android:gravity</span><span>=&quot;</span><span style="color:#a3be8c;">center</span><span>&quot;
</span><span>            </span><span style="color:#d08770;">android:text</span><span>=&quot;</span><span style="color:#a3be8c;">@{`计数器：`+ mNum}</span><span>&quot; /&gt;
</span><span>
</span><span>        &lt;</span><span style="color:#bf616a;">Button
</span><span>            </span><span style="color:#d08770;">android:id</span><span>=&quot;</span><span style="color:#a3be8c;">@+id/bt_databinding</span><span>&quot;
</span><span>            </span><span style="color:#d08770;">android:layout_width</span><span>=&quot;</span><span style="color:#a3be8c;">100dp</span><span>&quot;
</span><span>            </span><span style="color:#d08770;">android:layout_height</span><span>=&quot;</span><span style="color:#a3be8c;">wrap_content</span><span>&quot;
</span><span>            </span><span style="color:#d08770;">android:layout_gravity</span><span>=&quot;</span><span style="color:#a3be8c;">center_horizontal</span><span>&quot;
</span><span>            </span><span style="color:#d08770;">android:text</span><span>=&quot;</span><span style="color:#a3be8c;">增加</span><span>&quot; /&gt;
</span><span>
</span><span>    &lt;/</span><span style="color:#bf616a;">LinearLayout</span><span>&gt;
</span><span>&lt;/</span><span style="color:#bf616a;">layout</span><span>&gt;
</span></code></pre>
<p>使用variable属性写我们的变量，在到TextView中的android:text指向属性</p>
<p>再到activity中</p>
<pre data-lang="Kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-Kotlin "><code class="language-Kotlin" data-lang="Kotlin"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">DatabindingActivity </span><span>: </span><span style="color:#a3be8c;">AppCompatActivity</span><span>() {
</span><span>    </span><span style="color:#b48ead;">private val </span><span>binding </span><span style="color:#b48ead;">by</span><span> lazy {
</span><span>        ActivityDatabindingBinding.inflate(layoutInflater)
</span><span>    }
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onCreate</span><span>(savedInstanceState: Bundle?) {
</span><span>        </span><span style="color:#d08770;">super</span><span>.onCreate(savedInstanceState)
</span><span>        enableEdgeToEdge()
</span><span>        setContentView(binding.root)
</span><span>        binding.mNum = </span><span style="color:#d08770;">0
</span><span>        findViewById&lt;Button&gt;(R.id.bt_databinding).setOnClickListener {
</span><span>            binding.mNum++
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>这样同样实现了计数器的效果。</p>
<p>ok，关于DataBinding，我们就讲这些，如果想要深入了解的同学可以网上自行找资料，或者看下面的文章</p>
<p><a href="https://juejin.cn/post/6844903550808489998?searchId=202503201011098523E66CDAABD5A5B413">Data Binding (中文文档)这篇文档将教你如何运用 Data Binding 类库来编写声明试布局，并且尽量减 - 掘金</a></p>
<h1 id="navigation">Navigation</h1>
<p>大家应该都用过Fragment，而Navigation是为了我们更好的管理Fragment而推出的。</p>
<p>它有如下优点：</p>
<ul>
<li>可视化的页面导航图，便于我们理清页面间的关系。</li>
<li>通过destination和action完成页面间的导航。</li>
<li>方便添加页面切换动画。</li>
<li>页面间类型安全的参数传递。</li>
<li>通过NavigationUI类，对菜单、底部导航、抽屉菜单导航进行统一的管理。</li>
<li>支持深层链接DeepLink。</li>
</ul>
<h2 id="navigationde-shi-yong">Navigation的使用</h2>
<p>添加依赖</p>
<pre data-lang="Groovy" style="background-color:#2b303b;color:#c0c5ce;" class="language-Groovy "><code class="language-Groovy" data-lang="Groovy"><span>dependencies {
</span><span>    val nav_version = &quot;</span><span style="color:#a3be8c;">2.8.9</span><span>&quot;
</span><span>    implementation(&quot;</span><span style="color:#a3be8c;">androidx.navigation:navigation-fragment-ktx:</span><span style="color:#bf616a;">$nav_version</span><span>&quot;)
</span><span>    implementation(&quot;</span><span style="color:#a3be8c;">androidx.navigation:navigation-ui-ktx:</span><span style="color:#bf616a;">$nav_version</span><span>&quot;)
</span><span>}
</span></code></pre>
<p>我们先来认识一下，Navigation的三个组成</p>
<ul>
<li><strong>Navigation Graph</strong>：存放在<code>res/navigation</code>目录下，用来描述导航相关信息的 XML 资源</li>
<li><strong>NavHostFragment</strong>：显示导航图中目标的空白容器，其实就是用来放置 <code>fragment</code>的父容器</li>
<li><strong>NavController</strong>： 真正的用于导航动作实现的控制者，用于在代码中完成Navigation Graph中具体的页面切换工作。</li>
</ul>
<p>ok，认识完了之后，我们来学习一下用法</p>
<ol>
<li>创建Navigation Graph，新建<code>res/navigation</code>目录，依次选中res文件夹-&gt;New-&gt;Android Resource File</li>
</ol>
<p><img src="https://redrock.feishu.cn/space/api/box/stream/download/asynccode/?code=NzA4MDU4YmFhNGUxZWMxYzM2MmJhZTEzMjhlZDFjMGFfdVQ1MFFsS3Y5aHBHaXNOS010NEpEQW1UeElSMXMzS3BfVG9rZW46UW5DZWJvWVlib1o2emt4dEZYYWMxTGt3blhiXzE3NDcyMDE5OTE6MTc0NzIwNTU5MV9WNA" alt="img" /></p>
<p><img src="https://redrock.feishu.cn/space/api/box/stream/download/asynccode/?code=NzI5M2YzMTMzMmMxN2I4OWVlZjQwYTgzNmIxNjIxNTJfWVZETEcwWVRWRGtKaGlUMklTYngyY0ExSERuenBJVDZfVG9rZW46UlI1UWJWa24wb1BINmN4MVZUZ2MyUE1jblVoXzE3NDcyMDE5OTE6MTc0NzIwNTU5MV9WNA" alt="img" /></p>
<p>Resource type选择navigation。</p>
<ol>
<li>然后新建一个<code>navigation</code>的<code>resource</code>文件</li>
</ol>
<p><img src="https://redrock.feishu.cn/space/api/box/stream/download/asynccode/?code=NWU5YTFkZGJmMmQ1ZTIyMDViZWVhZjNmZTc3NWJkZjlfekhBdVQ3N01JZnNabEJqQ0c5dHZTR2JQWkR1OXQ2bWJfVG9rZW46SzR6cGIwWGI3b1psNUV4NVRETGNvbmFnbkJjXzE3NDcyMDE5OTE6MTc0NzIwNTU5MV9WNA" alt="img" /></p>
<ol>
<li>向其中添加我们的Fragment（这里准备了三个HomeFragment，BlankFragment，MineFragment）</li>
</ol>
<pre data-lang="xml" style="background-color:#2b303b;color:#c0c5ce;" class="language-xml "><code class="language-xml" data-lang="xml"><span>&lt;?</span><span style="color:#bf616a;">xml </span><span style="color:#d08770;">version</span><span>=&quot;</span><span style="color:#a3be8c;">1.0</span><span>&quot; </span><span style="color:#d08770;">encoding</span><span>=&quot;</span><span style="color:#a3be8c;">utf-8</span><span>&quot;?&gt;
</span><span>&lt;</span><span style="color:#bf616a;">navigation </span><span style="color:#d08770;">xmlns:android</span><span>=&quot;</span><span style="color:#a3be8c;">http://schemas.android.com/apk/res/android</span><span>&quot;
</span><span>    </span><span style="color:#d08770;">xmlns:app</span><span>=&quot;</span><span style="color:#a3be8c;">http://schemas.android.com/apk/res-auto</span><span>&quot;
</span><span>    </span><span style="color:#d08770;">xmlns:tools</span><span>=&quot;</span><span style="color:#a3be8c;">http://schemas.android.com/tools</span><span>&quot;
</span><span>    </span><span style="color:#d08770;">android:id</span><span>=&quot;</span><span style="color:#a3be8c;">@+id/nav_graph</span><span>&quot;
</span><span>    </span><span style="color:#d08770;">app:startDestination</span><span>=&quot;</span><span style="color:#a3be8c;">@+id/fragment_home</span><span>&quot;&gt;
</span><span>
</span><span>    &lt;</span><span style="color:#bf616a;">fragment
</span><span>        </span><span style="color:#d08770;">android:id</span><span>=&quot;</span><span style="color:#a3be8c;">@+id/fragment_home</span><span>&quot;
</span><span>        </span><span style="color:#d08770;">android:name</span><span>=&quot;</span><span style="color:#a3be8c;">com.sanhuzhen.jetpackdemo.fragment.HomeFragment</span><span>&quot;
</span><span>        </span><span style="color:#d08770;">android:label</span><span>=&quot;</span><span style="color:#a3be8c;">fragment_home</span><span>&quot;
</span><span>        </span><span style="color:#d08770;">tools:layout</span><span>=&quot;</span><span style="color:#a3be8c;">@layout/fragment_home</span><span>&quot;/&gt;
</span><span>    &lt;</span><span style="color:#bf616a;">fragment
</span><span>        </span><span style="color:#d08770;">android:id</span><span>=&quot;</span><span style="color:#a3be8c;">@+id/fragment_blank</span><span>&quot;
</span><span>        </span><span style="color:#d08770;">android:name</span><span>=&quot;</span><span style="color:#a3be8c;">com.sanhuzhen.jetpackdemo.fragment.BlankFragment</span><span>&quot;
</span><span>        </span><span style="color:#d08770;">android:label</span><span>=&quot;</span><span style="color:#a3be8c;">fragment_blank</span><span>&quot;
</span><span>        </span><span style="color:#d08770;">tools:layout</span><span>=&quot;</span><span style="color:#a3be8c;">@layout/fragment_blank</span><span>&quot; /&gt;
</span><span>
</span><span>    &lt;</span><span style="color:#bf616a;">fragment
</span><span>        </span><span style="color:#d08770;">android:id</span><span>=&quot;</span><span style="color:#a3be8c;">@+id/fragment_mine</span><span>&quot;
</span><span>        </span><span style="color:#d08770;">android:name</span><span>=&quot;</span><span style="color:#a3be8c;">com.sanhuzhen.jetpackdemo.fragment.MineFragment</span><span>&quot;
</span><span>        </span><span style="color:#d08770;">android:label</span><span>=&quot;</span><span style="color:#a3be8c;">fragment_mine</span><span>&quot;
</span><span>        </span><span style="color:#d08770;">tools:layout</span><span>=&quot;</span><span style="color:#a3be8c;">@layout/fragment_mine</span><span>&quot;/&gt;
</span><span>
</span><span>&lt;/</span><span style="color:#bf616a;">navigation</span><span>&gt;
</span></code></pre>
<p>加完之后，就可以用as进行可视化操作，实现不同fragment之间的跳转路径</p>
<p><img src="https://redrock.feishu.cn/space/api/box/stream/download/asynccode/?code=OTZjM2I0MGIxZjVjYTMxMTdjMmEyODRmM2FjODRiZjNfRWpNM05TN0tlWFBDZVNsODBMaWVXUEhWZ0JranhWSVZfVG9rZW46RjZaTGJnTjVub1ByanR4OGVjZWNnZEpybkFkXzE3NDcyMDE5OTE6MTc0NzIwNTU5MV9WNA" alt="img" /></p>
<p>之后可以看到xml文件中加了一点东西</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span>&lt;fragment
</span><span>    </span><span style="color:#bf616a;">android:id</span><span>=&quot;</span><span style="color:#a3be8c;">@+id/fragment_home</span><span>&quot;
</span><span>    </span><span style="color:#bf616a;">android:name</span><span>=&quot;</span><span style="color:#a3be8c;">com.sanhuzhen.jetpackdemo.fragment.HomeFragment</span><span>&quot;
</span><span>    </span><span style="color:#bf616a;">android:label</span><span>=&quot;</span><span style="color:#a3be8c;">fragment_home</span><span>&quot;
</span><span>    </span><span style="color:#bf616a;">tools:layout</span><span>=&quot;</span><span style="color:#a3be8c;">@layout/fragment_home</span><span>&quot;&gt;
</span><span>    &lt;action
</span><span>        </span><span style="color:#bf616a;">android:id</span><span>=&quot;</span><span style="color:#a3be8c;">@+id/action_fragment_home_to_fragment_blank</span><span>&quot;
</span><span>        </span><span style="color:#bf616a;">app:destination</span><span>=&quot;</span><span style="color:#a3be8c;">@id/fragment_blank</span><span>&quot; </span><span style="color:#bf616a;">/</span><span>&gt;
</span><span>&lt;/fragment&gt;
</span></code></pre>
<p>可以看到这里加了一个子结点action，子结点中的<code>destination</code>则定义了要跳转的目标<code>fragment</code></p>
<ol>
<li>在activity布局中的处理</li>
</ol>
<p>切换到activity的布局中来</p>
<pre data-lang="xml" style="background-color:#2b303b;color:#c0c5ce;" class="language-xml "><code class="language-xml" data-lang="xml"><span>&lt;?</span><span style="color:#bf616a;">xml </span><span style="color:#d08770;">version</span><span>=&quot;</span><span style="color:#a3be8c;">1.0</span><span>&quot; </span><span style="color:#d08770;">encoding</span><span>=&quot;</span><span style="color:#a3be8c;">utf-8</span><span>&quot;?&gt;
</span><span>&lt;</span><span style="color:#bf616a;">androidx.constraintlayout.widget.ConstraintLayout </span><span style="color:#d08770;">xmlns:android</span><span>=&quot;</span><span style="color:#a3be8c;">http://schemas.android.com/apk/res/android</span><span>&quot;
</span><span>    </span><span style="color:#d08770;">xmlns:app</span><span>=&quot;</span><span style="color:#a3be8c;">http://schemas.android.com/apk/res-auto</span><span>&quot;
</span><span>    </span><span style="color:#d08770;">xmlns:tools</span><span>=&quot;</span><span style="color:#a3be8c;">http://schemas.android.com/tools</span><span>&quot;
</span><span>    </span><span style="color:#d08770;">android:id</span><span>=&quot;</span><span style="color:#a3be8c;">@+id/main</span><span>&quot;
</span><span>    </span><span style="color:#d08770;">android:layout_width</span><span>=&quot;</span><span style="color:#a3be8c;">match_parent</span><span>&quot;
</span><span>    </span><span style="color:#d08770;">android:layout_height</span><span>=&quot;</span><span style="color:#a3be8c;">match_parent</span><span>&quot;
</span><span>    </span><span style="color:#d08770;">tools:context</span><span>=&quot;</span><span style="color:#a3be8c;">.activity.NavActivity</span><span>&quot;&gt;
</span><span>    &lt;</span><span style="color:#bf616a;">fragment
</span><span>        </span><span style="color:#d08770;">android:id</span><span>=&quot;</span><span style="color:#a3be8c;">@+id/nav_host_fragment</span><span>&quot;
</span><span>        </span><span style="color:#d08770;">android:name</span><span>=&quot;</span><span style="color:#a3be8c;">androidx.navigation.fragment.NavHostFragment</span><span>&quot;
</span><span>        </span><span style="color:#d08770;">android:layout_width</span><span>=&quot;</span><span style="color:#a3be8c;">match_parent</span><span>&quot;
</span><span>        </span><span style="color:#d08770;">android:layout_height</span><span>=&quot;</span><span style="color:#a3be8c;">match_parent</span><span>&quot;
</span><span>        </span><span style="color:#d08770;">app:defaultNavHost</span><span>=&quot;</span><span style="color:#a3be8c;">true</span><span>&quot;
</span><span>        </span><span style="color:#d08770;">app:navGraph</span><span>=&quot;</span><span style="color:#a3be8c;">@navigation/nav_graph</span><span>&quot;/&gt;
</span><span>&lt;/</span><span style="color:#bf616a;">androidx.constraintlayout.widget.ConstraintLayout</span><span>&gt;
</span></code></pre>
<p>在其布局文件中添加一个fragment或者fragmentContainerView，将其name属性设置为下面</p>
<pre data-lang="xml" style="background-color:#2b303b;color:#c0c5ce;" class="language-xml "><code class="language-xml" data-lang="xml"><span>android:name=&quot;androidx.navigation.fragment.NavHostFragment&quot;
</span></code></pre>
<p><code>NavHostFragment</code>是作为<code>Navigation</code>中<code>fragment</code>的显示载体来出现的</p>
<p><code>app:defaultNavHost="true"</code>这个表面该Fragment会自动处理系统返回键。即当用户按下手机的返回按钮时，系统能自动将当前所展示的Fragment退出。</p>
<p><code>app:navGraph</code>则是设置该Fragment对应的导航图</p>
<ol>
<li>跳转页面</li>
</ol>
<p>来到我们的HomeFragment的布局中，添加一个按钮</p>
<pre data-lang="xml" style="background-color:#2b303b;color:#c0c5ce;" class="language-xml "><code class="language-xml" data-lang="xml"><span>&lt;?</span><span style="color:#bf616a;">xml </span><span style="color:#d08770;">version</span><span>=&quot;</span><span style="color:#a3be8c;">1.0</span><span>&quot; </span><span style="color:#d08770;">encoding</span><span>=&quot;</span><span style="color:#a3be8c;">utf-8</span><span>&quot;?&gt;
</span><span>&lt;</span><span style="color:#bf616a;">FrameLayout </span><span style="color:#d08770;">xmlns:android</span><span>=&quot;</span><span style="color:#a3be8c;">http://schemas.android.com/apk/res/android</span><span>&quot;
</span><span>    </span><span style="color:#d08770;">xmlns:tools</span><span>=&quot;</span><span style="color:#a3be8c;">http://schemas.android.com/tools</span><span>&quot;
</span><span>    </span><span style="color:#d08770;">android:layout_width</span><span>=&quot;</span><span style="color:#a3be8c;">match_parent</span><span>&quot;
</span><span>    </span><span style="color:#d08770;">android:layout_height</span><span>=&quot;</span><span style="color:#a3be8c;">match_parent</span><span>&quot;
</span><span>    </span><span style="color:#d08770;">tools:context</span><span>=&quot;</span><span style="color:#a3be8c;">.fragment.HomeFragment</span><span>&quot;&gt;
</span><span>    &lt;</span><span style="color:#bf616a;">TextView
</span><span>        </span><span style="color:#d08770;">android:layout_width</span><span>=&quot;</span><span style="color:#a3be8c;">match_parent</span><span>&quot;
</span><span>        </span><span style="color:#d08770;">android:layout_height</span><span>=&quot;</span><span style="color:#a3be8c;">match_parent</span><span>&quot;
</span><span>        </span><span style="color:#d08770;">android:text</span><span>=&quot;</span><span style="color:#a3be8c;">@string/hello_blank_fragment</span><span>&quot; /&gt;
</span><span>    &lt;</span><span style="color:#bf616a;">Button
</span><span>        </span><span style="color:#d08770;">android:id</span><span>=&quot;</span><span style="color:#a3be8c;">@+id/btn_test</span><span>&quot;
</span><span>        </span><span style="color:#d08770;">android:layout_width</span><span>=&quot;</span><span style="color:#a3be8c;">wrap_content</span><span>&quot;
</span><span>        </span><span style="color:#d08770;">android:layout_height</span><span>=&quot;</span><span style="color:#a3be8c;">wrap_content</span><span>&quot;
</span><span>        </span><span style="color:#d08770;">android:layout_gravity</span><span>=&quot;</span><span style="color:#a3be8c;">center</span><span>&quot;
</span><span>        </span><span style="color:#d08770;">android:text</span><span>=&quot;</span><span style="color:#a3be8c;">跳转</span><span>&quot; /&gt;
</span><span>&lt;/</span><span style="color:#bf616a;">FrameLayout</span><span>&gt;
</span></code></pre>
<p>然后来到HomeFragment</p>
<pre data-lang="Kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-Kotlin "><code class="language-Kotlin" data-lang="Kotlin"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">HomeFragment </span><span>: </span><span style="color:#a3be8c;">Fragment</span><span>() {
</span><span>
</span><span>    </span><span style="color:#b48ead;">private var </span><span>_binding: FragmentHomeBinding? = </span><span style="color:#d08770;">null
</span><span>    </span><span style="color:#b48ead;">private val </span><span>binding get() = _binding!!
</span><span>
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onCreateView</span><span>(
</span><span>        inflater: LayoutInflater, container: ViewGroup?,
</span><span>        savedInstanceState: Bundle?
</span><span>    ): View {
</span><span>        _binding = FragmentHomeBinding.inflate(inflater, container, </span><span style="color:#d08770;">false</span><span>)
</span><span>        </span><span style="color:#b48ead;">return</span><span> binding.root
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onViewCreated</span><span>(view: View, savedInstanceState: Bundle?) {
</span><span>        </span><span style="color:#d08770;">super</span><span>.onViewCreated(view, savedInstanceState)
</span><span>        binding.btn.setOnClickListener {
</span><span>            Navigation.findNavController(it).navigate(R.id.action_fragment_home_to_fragment_blank)
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onDestroyView</span><span>() {
</span><span>        </span><span style="color:#d08770;">super</span><span>.onDestroyView()
</span><span>        _binding = </span><span style="color:#d08770;">null  </span><span style="color:#65737e;">// 避免内存泄漏
</span><span>    }
</span><span>}
</span></code></pre>
<p>这里使用ViewBinding，但Fragment存在时间比其视图长。请务必在 <code>Fragment</code> 的 <code>onDestroyView()</code> 方法中清除对绑定类实例的所有引用。</p>
<pre data-lang="Kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-Kotlin "><code class="language-Kotlin" data-lang="Kotlin"><span>Navigation.findNavController(it).navigate(R.id.action_fragment_home_to_fragment_blank)
</span></code></pre>
<p>使用上面这句进行页面跳转，这里的id即是我们的action的id</p>
<h1 id="room">Room</h1>
<h2 id="shen-me-shi-room">什么是Room？</h2>
<p>Room是是用于处理本地数据库的库。Room 持久性库在 SQLite 上提供了一个抽象层，以便在充分利用 SQLite 的强大功能的同时，能够流畅地访问数据库。具体来说，Room 具有以下优势：</p>
<ul>
<li>针对 SQL 查询的编译时验证。</li>
<li>可最大限度减少重复和容易出错的样板代码的方便注解。</li>
<li>简化了数据库迁移路径。</li>
</ul>
<h2 id="roomde-zu-cheng">Room的组成</h2>
<p>Room主要包括三个组件：</p>
<ul>
<li><strong>DataBase</strong>：保存数据库并作为应用持久性数据底层连接的主要访问点</li>
<li><strong>Entity</strong>：用于表示应用的数据库中的表</li>
<li><strong>Dao</strong>：提供你的应用可用于查询、更新、插入和删除数据库中的数据的方法</li>
</ul>
<p>我们在使用时一般都先通过DataBase获取到Dao，然后用Dao来操作Entity</p>
<h2 id="roomde-shi-yong">Room的使用</h2>
<p>首先添加依赖</p>
<pre data-lang="Kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-Kotlin "><code class="language-Kotlin" data-lang="Kotlin"><span>dependencies {
</span><span>    </span><span style="color:#b48ead;">val </span><span>room_version = &quot;</span><span style="color:#a3be8c;">2.6.1</span><span>&quot;
</span><span>    implementation(&quot;</span><span style="color:#a3be8c;">androidx.room:room-runtime:</span><span style="color:#bf616a;">$room_version</span><span>&quot;)
</span><span>    annotationProcessor(&quot;</span><span style="color:#a3be8c;">androidx.room:room-compiler:</span><span style="color:#bf616a;">$room_version</span><span>&quot;)
</span><span>}
</span></code></pre>
<h3 id="jian-biao">建表</h3>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span>@Entity
</span><span style="color:#b48ead;">data class </span><span style="color:#ebcb8b;">User</span><span>(
</span><span>    @PrimaryKey // 主键
</span><span>    </span><span style="color:#b48ead;">var </span><span>uId: </span><span style="color:#b48ead;">Int</span><span>,
</span><span>    @ColumnInfo(name = &quot;</span><span style="color:#a3be8c;">user_name</span><span>&quot;)
</span><span>    </span><span style="color:#b48ead;">var </span><span>userName: </span><span style="color:#b48ead;">String</span><span>,
</span><span>    @ColumnInfo(name = &quot;</span><span style="color:#a3be8c;">user_age</span><span>&quot;)
</span><span>    </span><span style="color:#b48ead;">var </span><span>userAge: </span><span style="color:#b48ead;">Int</span><span>,
</span><span>    @Ignore
</span><span>    </span><span style="color:#b48ead;">var </span><span>gender: </span><span style="color:#b48ead;">String
</span><span>)
</span></code></pre>
<ul>
<li><code>@Entity</code>：用于将User类与Room中的数据表对应起来。tableName属性可以为数据表设置表 名，若不设置，则表名和类名相同。</li>
<li><code>@PrimaryKey</code>：用于指定该字段作为表的主键</li>
<li><code>@ColumnInfo</code>：用于设置该字段存储在数据库表中的名字。若不设置，则默认使用字段名称作为数据库中的列名称</li>
<li><code>@Ignore</code>：告诉Room忽略该字段或方法</li>
</ul>
<p>当然，还有其他的，感兴趣可以点击下面链接</p>
<p>https://juejin.cn/post/7205417093973884983?searchId=202503221327580BFBF2FE3B9DF27C8C76</p>
<h3 id="chuang-jian-shu-ju-fang-wen-dui-xiang-dao">创建数据访问对象(DAO)</h3>
<p>新建一个名为UserDao的接口文件，并在接口的上方添加@Dao标签。</p>
<ul>
<li><code>@Insert</code>：定义将其参数插入数据库中的相应表的方法。</li>
<li><code>@Update</code>：定义用于更新数据库表中特定行的方法。</li>
<li><code>@Delete</code>：定义用于从数据库表中删除特定行的方法。</li>
<li><code>@Query</code>：定义用于自己编写 SQL 语句</li>
</ul>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span>@Dao
</span><span style="color:#b48ead;">interface </span><span style="color:#ebcb8b;">UserDao</span><span> {
</span><span>    </span><span style="color:#65737e;">/**
</span><span style="color:#65737e;">     * 插入数据，当主键冲突时选择直接覆盖原数据
</span><span style="color:#65737e;">     *
</span><span style="color:#65737e;">     * 可选数据：
</span><span style="color:#65737e;">     * OnConflictStrategy.REPLACE 如果发生冲突，直接覆盖已有数据，将表中现存的数据替换成插入的这条；
</span><span style="color:#65737e;">     * OnConflictStrategy.IGNORE 如果发生冲突，直接忽略此次插入操作
</span><span style="color:#65737e;">     * OnConflictStrategy.NONE 这个是默认的策略，它和ABORT作用是一致的，都是终止此次插入操作，并且抛出SQLiteConstraintException
</span><span style="color:#65737e;">     * OnConflictStrategy.ROLLBACK 这个表示如果发生冲突，终止插入操作，并且将事务回滚到最初的状态，在最新版本已经被标记@Deprecated推荐使用ABORT
</span><span style="color:#65737e;">     * OnConflictStrategy.ABORT 和NONE作用一致，这里就不过多介绍
</span><span style="color:#65737e;">     * OnConflictStrategy.FAIL 这个表示如果发生冲突，终止插入操作，并且抛出SQLiteConstraintException异常，在最新版本也是被标记@Deprecated，也是推荐使用ABORT。
</span><span style="color:#65737e;">     */
</span><span>    @Insert(onConflict = OnConflictStrategy.</span><span style="color:#d08770;">REPLACE</span><span>)
</span><span>    </span><span style="color:#b48ead;">fun </span><span style="color:#8fa1b3;">insert</span><span>(user: User)
</span><span>
</span><span>    </span><span style="color:#65737e;">/**
</span><span style="color:#65737e;">     * 删除数据
</span><span style="color:#65737e;">     */
</span><span>    @Delete
</span><span>    </span><span style="color:#b48ead;">fun </span><span style="color:#8fa1b3;">delete</span><span>(user: User)
</span><span>
</span><span>    </span><span style="color:#65737e;">/**
</span><span style="color:#65737e;">     * 删除所有用户，使用Query注解可以执行自定义的SQL语句
</span><span style="color:#65737e;">     */
</span><span>    @Query(&quot;</span><span style="color:#a3be8c;">DELETE FROM user</span><span>&quot;)
</span><span>    </span><span style="color:#b48ead;">fun </span><span style="color:#8fa1b3;">deleteAll</span><span>()
</span><span>
</span><span>    </span><span style="color:#65737e;">/**
</span><span style="color:#65737e;">     * 更新数据
</span><span style="color:#65737e;">     */
</span><span>    @Update
</span><span>    </span><span style="color:#b48ead;">fun </span><span style="color:#8fa1b3;">update</span><span>(user: User)
</span><span>
</span><span>    </span><span style="color:#65737e;">/**
</span><span style="color:#65737e;">     * 查询数据
</span><span style="color:#65737e;">     */
</span><span>    @Query(&quot;</span><span style="color:#a3be8c;">select * from user where uId=:id</span><span>&quot;)
</span><span>    </span><span style="color:#b48ead;">fun </span><span style="color:#8fa1b3;">queryById</span><span>(id : </span><span style="color:#b48ead;">Int</span><span>): User?
</span><span>
</span><span>    @Query(&quot;</span><span style="color:#a3be8c;">select * from user</span><span>&quot;)
</span><span>    </span><span style="color:#b48ead;">fun </span><span style="color:#8fa1b3;">queryAll</span><span>(): </span><span style="color:#b48ead;">List</span><span>&lt;User&gt;
</span><span>}
</span></code></pre>
<h3 id="chuang-jian-shu-ju-ku">创建数据库</h3>
<p><code>@Database</code>用于告诉系统这是Room数据库对象。</p>
<p><code>entities</code>属性用于指定该数据库有哪些表，若需要建立多张表，则表名以逗号隔开。</p>
<p><code>version</code>属性用于指定数据库版本号，后面数据库的升级正是依据版本号进行判断的。</p>
<p>数据库类必须是一个抽象类，用于拓展<code>RoomDatabase</code>。对于与数据库关联的每个DAO类，数据库类必须定义一个具有零参数的抽象方法，并返回 DAO 类的实例。</p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span>@Database(entities = [User::class], version = </span><span style="color:#d08770;">1</span><span>)
</span><span style="color:#b48ead;">abstract class </span><span style="color:#ebcb8b;">AppDataBase</span><span>: </span><span style="color:#a3be8c;">RoomDatabase</span><span>() {
</span><span>    </span><span style="color:#b48ead;">abstract fun </span><span style="color:#8fa1b3;">userDao</span><span>(): UserDao
</span><span>}
</span></code></pre>
<h3 id="shi-yong">使用</h3>
<p>创造数据库实例</p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">RoomActivity </span><span>: </span><span style="color:#a3be8c;">AppCompatActivity</span><span>() {
</span><span>
</span><span>    </span><span style="color:#b48ead;">private val </span><span>userDataBase </span><span style="color:#b48ead;">by</span><span> lazy {
</span><span>        Room.databaseBuilder(</span><span style="color:#d08770;">this</span><span>, AppDataBase::class.java, &quot;</span><span style="color:#a3be8c;">user.db</span><span>&quot;).build()
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">onCreate</span><span>(savedInstanceState: Bundle?) {
</span><span>        </span><span style="color:#d08770;">super</span><span>.onCreate(savedInstanceState)
</span><span>        enableEdgeToEdge()
</span><span>        setContentView(R.layout.activity_room)
</span><span>
</span><span>    }
</span><span>}
</span></code></pre>
<p>通过懒加载创造数据库实例，然后就可以用Dao去处理相关数据</p>
<p><img src="https://redrock.feishu.cn/space/api/box/stream/download/asynccode/?code=MTk4NTQ1NDQ2YTQyZGVkMjU1ZGQyOWUzZTA2MTVlOTlfaHJZQ0ZrczhZbGdtS0hPc2kxbnlJVU1hckVPUUNza21fVG9rZW46RWRJQWI0WVlob25adnF4c2N5OGM2eEtRbkllXzE3NDcyMDE5OTE6MTc0NzIwNTU5MV9WNA" alt="img" /></p>
<p>除了上述方法，我们也可以在AppDatabase里封装实例化数据库的代码</p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span style="color:#b48ead;">companion object</span><span> {
</span><span>    </span><span style="color:#b48ead;">private</span><span> lateinit </span><span style="color:#b48ead;">var </span><span>INSTANCE: AppDataBase
</span><span>    </span><span style="color:#b48ead;">fun </span><span style="color:#8fa1b3;">getDatabase</span><span>(context: Context): AppDataBase {
</span><span>        synchronized(AppDataBase::class) {
</span><span>            </span><span style="color:#b48ead;">if</span><span> (!::</span><span style="color:#d08770;">INSTANCE</span><span>.isInitialized) {
</span><span>                </span><span style="color:#d08770;">INSTANCE </span><span>= Room.databaseBuilder(
</span><span>                    context, AppDataBase::class.java, &quot;</span><span style="color:#a3be8c;">user.db</span><span>&quot;
</span><span>                ).fallbackToDestructiveMigration().build()
</span><span>            }
</span><span>        }
</span><span>        </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">INSTANCE
</span><span>    }
</span><span>}
</span></code></pre>
<h2 id="sheng-ji-shu-ju-ku">升级数据库</h2>
<p>当我们要增加或删除数据库中字段名，我们就需要升级数据库的版本，在Room中，我们可以通过<code>@DataBase</code>中的<code>autoMigrations</code>属性来完成，比如我们想将user_name列名改为userName</p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span>@Database(
</span><span>    entities = [User::class],
</span><span>    version = </span><span style="color:#d08770;">2</span><span>,
</span><span>    autoMigrations = [AutoMigration(</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2</span><span>, ReNameColumnMigration::class)]
</span><span>)
</span><span style="color:#b48ead;">abstract class </span><span style="color:#ebcb8b;">AppDataBase </span><span>: </span><span style="color:#a3be8c;">RoomDatabase</span><span>() {
</span><span>    </span><span style="color:#b48ead;">abstract fun </span><span style="color:#8fa1b3;">userDao</span><span>(): UserDao
</span><span>}
</span><span>
</span><span>@RenameColumn(fromColumnName = &quot;</span><span style="color:#a3be8c;">user_name</span><span>&quot;, tableName = &quot;</span><span style="color:#a3be8c;">user</span><span>&quot;, toColumnName = &quot;</span><span style="color:#a3be8c;">userName</span><span>&quot;)
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">ReNameColumnMigration </span><span>: </span><span style="color:#a3be8c;">AutoMigrationSpec
</span></code></pre>
<p>或者通过Migration 类来手动定义迁移路径，比如我们想加一列birthday</p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span style="color:#b48ead;">val </span><span>MIGRATION_1_2 = </span><span style="color:#b48ead;">object </span><span>: </span><span style="color:#a3be8c;">Migration</span><span>(</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2</span><span>) {
</span><span>    </span><span style="color:#b48ead;">override fun </span><span style="color:#8fa1b3;">migrate</span><span>(database: SupportSQLiteDatabase) {
</span><span>        database.execSQL(&quot;</span><span style="color:#a3be8c;">ALTER TABLE user ADD COLUMN birthday TEXT</span><span>&quot;)
</span><span>    }
</span><span>}
</span></code></pre>
<p>然后再到创建实例时</p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span style="color:#b48ead;">fun </span><span style="color:#8fa1b3;">getDatabase</span><span>(context: Context): AppDataBase {
</span><span>    synchronized(AppDataBase::class) {
</span><span>        </span><span style="color:#b48ead;">if</span><span> (!::</span><span style="color:#d08770;">INSTANCE</span><span>.isInitialized) {
</span><span>            </span><span style="color:#d08770;">INSTANCE </span><span>= Room.databaseBuilder(
</span><span>                context.applicationContext, AppDataBase::class.java, &quot;</span><span style="color:#a3be8c;">user.db</span><span>&quot;
</span><span>            ).addMigrations(</span><span style="color:#d08770;">MIGRATION_1_2</span><span>).fallbackToDestructiveMigration().build()
</span><span>        }
</span><span>    }
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">INSTANCE
</span><span>}
</span></code></pre>


            </main>
            <footer>
                
<p class="taxonomies">


<a href="/tags/android">#Android</a>

<a href="/tags/jetpack">#Jetpack</a>



<a href="/categories/android">+Android</a>




</p>

                
                <nav>
                    
                    <a href="https://github.com/sanhuzhen">Github</a>
                    
                </nav>
                
            </footer>
        </div>
    </body>
</html>