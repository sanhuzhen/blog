<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta content="IE=edge" http-equiv="X-UA-Compatible"/>
        <meta content="text/html; charset=UTF-8" http-equiv="content-type"/>
        <meta content="width=device-width, initial-scale=1" name="viewport"/>

        
        
        

        
        
        

        

        
        
        

        
        
        

        <title>rust的基本语法</title>
        
        <meta name="title" content="rust的基本语法">
        <meta name="author" content="sanhuzhen">
        
        <meta name="generator" content="Zola v0.16.1">

        <meta property="og:type" content="website">
        <meta property="og:url" content="https://blog.sanhuzhen.top/posts/rustde-ji-chu-yu-fa/">
        <meta property="og:site_name" content="sanhuzhen&#x27;s Blog">
        <meta property="og:title" content="rust的基本语法">
        
        <meta property="og:image" content="https:&#x2F;&#x2F;blog.sanhuzhen.top&#x2F;images&#x2F;logo.png">

        
        
        <meta property="twitter:card" content="summary_large_image">
        <meta property="twitter:url" content="https://blog.sanhuzhen.top/posts/rustde-ji-chu-yu-fa/">
        <meta property="twitter:title" content="rust的基本语法">
        
        <meta property="twitter:image" content="https:&#x2F;&#x2F;blog.sanhuzhen.top&#x2F;images&#x2F;logo.png">
        
        
        <link rel="canonical" href="https://blog.sanhuzhen.top/posts/rustde-ji-chu-yu-fa/">
        <link rel="shortcut icon" type="image/x-icon" href="https://blog.sanhuzhen.top/images/logo.png">
        <script type="application/ld+json">
            {
                
                "url":"https://blog.sanhuzhen.top/posts/rustde-ji-chu-yu-fa/",
                "@type":"WebSite",
                "headline":"rust的基本语法",
                "name":"rust的基本语法",
                "author":{
                    "@type":"Person",
                    "name":"sanhuzhen"
                },
                "@context":"https://schema.org"
            }
        </script>
        
        
        
        <link rel="stylesheet" href="https://blog.sanhuzhen.top/style.css"/>
        
    </head>
    <body theme="auto">
        <div class="w">
            <header>
                
                <nav>
                    
                    <a href="https://blog.sanhuzhen.top/about" >about</a>
                    
                    <a href="https://blog.sanhuzhen.top" >home</a>
                    
                    <a href="https://blog.sanhuzhen.top/posts" >archive</a>
                    
                    <a href="https://blog.sanhuzhen.top/tags" >tags</a>
                    
                    <a href="https://blog.sanhuzhen.top/categories" >categories</a>
                    
                </nav>
                
                
<p><a href="..">..</a>/rustde-ji-chu-yu-fa</p>
<p class="post-meta"><time datetime="2024-11-01">2024-11-01</time></p>
<h1>rust的基本语法</h1>

            </header>
            <main class="page-content" aria-label="Content">
                



<p>打印 <code> Hello,World!</code></p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>(){
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Hello,World!</span><span>&quot;);
</span><span>}
</span></code></pre>
<h2 id="bian-liang">变量</h2>
<h3 id="ke-bian-xing">可变性</h3>
<p>rust中的变量与kotlin同样具有可变性和不可变性</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let</span><span> m = </span><span style="color:#d08770;">6</span><span>;
</span><span>m = </span><span style="color:#d08770;">7</span><span>;
</span></code></pre>
<p>上述就会报错，因为直接使用 <code> let</code>声明的变量具备不可变性，即赋值一次就不可变了，与kotlin中的 <code> val</code>一致</p>
<p>但我们可以用 <code> mut</code>来将变量 <code> m</code>赋予可变性，即</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let mut</span><span> m = </span><span style="color:#d08770;">6</span><span>;
</span><span>m = </span><span style="color:#d08770;">7</span><span>;
</span></code></pre>
<h3 id="chang-liang">常量</h3>
<p>同理，rust中一样会有常量，这时我们可以与其他语言一样，用 <code> const</code>来声明常量</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">const </span><span style="color:#d08770;">MATH</span><span>.</span><span style="color:#d08770;">PI</span><span>: </span><span style="color:#b48ead;">f64 </span><span>= </span><span style="color:#d08770;">3.1415926</span><span>;
</span></code></pre>
<p>常量默认不可变，并且必须表明其类型，比如上述的 <code> f64</code>就表明 <code> MATH.PI</code>是一个浮点数</p>
<h3 id="yin-cang">隐藏</h3>
<p>rust中如果我们在后面新定义了一个与前面变量名一样的变量，我们就说前一个变量就被这一个变量给隐藏了。</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>(){
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> x = </span><span style="color:#d08770;">3</span><span>;
</span><span>    x = x * </span><span style="color:#d08770;">2</span><span>;
</span><span>    {
</span><span>        </span><span style="color:#b48ead;">let</span><span> x = x * </span><span style="color:#d08770;">2</span><span>;
</span><span>        println!(&quot;</span><span style="color:#d08770;">{x}</span><span>&quot;);
</span><span>    }
</span><span>    println!(&quot;</span><span style="color:#d08770;">{x}</span><span>&quot;);
</span><span>}
</span><span>输出：
</span><span style="color:#d08770;">12
</span><span style="color:#d08770;">6
</span><span>
</span></code></pre>
<p><code> {}</code>就是一个作用域，我们在新的作用域中使用 <code>let x =</code>又新创造了一个新的变量，将之前的隐藏了，当 <code> {}</code>结束后，x又返回之前的值，故输出6。</p>
<p><code> mut</code>和隐藏的区别：</p>
<ul>
<li>
<p><code> mut</code>并不会受作用域的影响，如上这个程序，如果不用 <code> let x =</code>去新创造一个变量，仅单单 <code> x = x * 2</code>那么，酒后程序输出的都是12</p>
</li>
<li>
<p><code> mut</code>还不会改变变量的类型，而隐藏可以改变这个新的变量的类型</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>(){
</span><span>    </span><span style="color:#b48ead;">let str </span><span>= &quot;   &quot;;
</span><span>    </span><span style="color:#b48ead;">let str </span><span>= </span><span style="color:#b48ead;">str</span><span>.</span><span style="color:#96b5b4;">len</span><span>();
</span><span>}
</span></code></pre>
<p>如上，我们创造了一个 <code> str</code>字符串，后又用 <code> str</code>来表示 <code> str</code>的长度，二者的类型是不同的，但我们可以用隐藏来实现，如果用 <code> mut</code>那肯定就不行。</p>
</li>
</ul>
<h2 id="shu-ju-lei-xing">数据类型</h2>
<p>rust是一门静态类型语言，这表明编译器在编译时，就需要知道所有变量的类型。</p>
<p>rust的数据类型主要分为：</p>
<ul>
<li>标类：整型，浮点型，布尔型和字符类型（感觉其他语言的基本类型也是这些？）</li>
<li>复合</li>
</ul>
<h3 id="biao-lei">标类</h3>
<h4 id="zheng-xing">整型</h4>
<table><thead><tr><th>有符号</th><th>无符号</th></tr></thead><tbody>
<tr><td><code> i8</code></td><td><code> u8</code></td></tr>
<tr><td><code> i16</code></td><td><code> u16</code></td></tr>
<tr><td><code> i32</code></td><td><code> u32</code></td></tr>
<tr><td><code> i64</code></td><td><code> u64</code></td></tr>
<tr><td><code> i128</code></td><td><code> u128</code></td></tr>
<tr><td><code> isize</code></td><td><code> usize</code></td></tr>
</tbody></table>
<p>有无符号代表该数是否可以为负数</p>
<p><code> isize</code>和 <code> usize</code>类型依赖于运行程序的计算机架构，64位为64位，32位为32位</p>
<h4 id="fu-dian-shu">浮点数</h4>
<p><code> f32</code>和 <code> f64</code>分别占32位和64位，rust默认位 <code> f64</code>.</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>(){
</span><span>    </span><span style="color:#b48ead;">let</span><span> x = </span><span style="color:#d08770;">3.2</span><span>;</span><span style="color:#65737e;">//f64
</span><span>    </span><span style="color:#b48ead;">let</span><span> x: </span><span style="color:#b48ead;">f32 </span><span>= </span><span style="color:#d08770;">3.2</span><span>;</span><span style="color:#65737e;">//f32
</span><span>}
</span></code></pre>
<h4 id="bu-er-xing">布尔型</h4>
<p>与其他语言一样，rust也有 <code> bool</code>型变量</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>(){
</span><span>    </span><span style="color:#b48ead;">let</span><span> target = </span><span style="color:#d08770;">true</span><span>;
</span><span>    </span><span style="color:#b48ead;">let</span><span> target: </span><span style="color:#b48ead;">bool </span><span>= </span><span style="color:#d08770;">false</span><span>;
</span><span>}
</span></code></pre>
<h4 id="zi-fu-lei-xing">字符类型</h4>
<p><code> char</code>主要用来表示字符类型，字符一般用单引号来声明 <code> char</code>字面量</p>
<h3 id="fu-he">复合</h3>
<p>rust中将多个值组合成一个类型，rust有两个原生的复合类型：</p>
<ul>
<li>元组（tuple）</li>
<li>数组（array）</li>
</ul>
<h4 id="yuan-zu">元组</h4>
<p>元组是一个将多个其他类型的值组合进一个复合类型的主要方式。</p>
<p>元组长度固定：一旦声明，其长度不会增大或缩小。</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>(){
</span><span>    </span><span style="color:#b48ead;">let</span><span> tup: (</span><span style="color:#b48ead;">i32</span><span>, </span><span style="color:#b48ead;">f64</span><span>, </span><span style="color:#b48ead;">u32</span><span>) = (</span><span style="color:#d08770;">500</span><span>, </span><span style="color:#d08770;">3.14</span><span>, </span><span style="color:#d08770;">2</span><span>);
</span><span>}
</span></code></pre>
<h5 id="jie-gou">解构</h5>
<p>为了从元组中获取单个值，可以使用模式匹配（pattern matching）来解构（destructure）元组值</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>(){
</span><span>    </span><span style="color:#b48ead;">let</span><span> tup: (</span><span style="color:#b48ead;">i32</span><span>, </span><span style="color:#b48ead;">f64</span><span>, </span><span style="color:#b48ead;">u32</span><span>) = (</span><span style="color:#d08770;">500</span><span>, </span><span style="color:#d08770;">3.14</span><span>, </span><span style="color:#d08770;">2</span><span>);
</span><span>    </span><span style="color:#b48ead;">let </span><span>(x, y, z) = tup;
</span><span>    println!(&quot;</span><span style="color:#d08770;">{y}</span><span>&quot;);
</span><span>}
</span><span>输出：
</span><span style="color:#d08770;">3.14
</span><span>
</span></code></pre>
<p>我们也可以使用点号（<code>.</code>）后跟值的索引来直接访问它们（索引从0开始）</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>(){
</span><span>    </span><span style="color:#b48ead;">let</span><span> tup: (</span><span style="color:#b48ead;">i32</span><span>, </span><span style="color:#b48ead;">f64</span><span>, </span><span style="color:#b48ead;">u32</span><span>) = (</span><span style="color:#d08770;">500</span><span>, </span><span style="color:#d08770;">3.14</span><span>, </span><span style="color:#d08770;">2</span><span>);
</span><span>    </span><span style="color:#b48ead;">let</span><span> y = tup.</span><span style="color:#d08770;">1</span><span>;
</span><span>    println!(&quot;</span><span style="color:#d08770;">{y}</span><span>&quot;);
</span><span>}
</span></code></pre>
<p>不带任何值的元组有个特殊的名称，叫做 <strong>单元（unit）</strong> 元组。这种值以及对应的类型都写作 <code>()</code>，表示空值或空的返回类型。如果表达式不返回任何其他值，则会隐式返回单元值。</p>
<h4 id="shu-zu">数组</h4>
<p>数组中的每个元素的类型必须相同</p>
<p>我们将数组的值写成在方括号内，用逗号分隔：</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>(){
</span><span>    </span><span style="color:#b48ead;">let</span><span> nums = [</span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">4</span><span>];
</span><span>}
</span></code></pre>
<p>可以像这样编写数组的类型：在方括号中包含每个元素的类型，后跟分号，再后跟数组元素的数量。</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>(){
</span><span>    </span><span style="color:#b48ead;">let</span><span> nums: [</span><span style="color:#b48ead;">i32</span><span>: </span><span style="color:#d08770;">5</span><span>] = [</span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">4</span><span>];
</span><span>}
</span></code></pre>
<p>通过在方括号中指定初始值加分号再加元素个数的方式来创建一个每个元素都为相同值的数组：</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>(){
</span><span>    </span><span style="color:#b48ead;">let</span><span> nums = [</span><span style="color:#d08770;">3</span><span>: </span><span style="color:#d08770;">5</span><span>];
</span><span>    </span><span style="color:#65737e;">//等价于 let nums = [3, 3, 3, 3, 3];
</span><span>}
</span></code></pre>
<h2 id="han-shu">函数</h2>
<p>对于任意语言，都有函数这个概念，rust也一样</p>
<p>rust主要用 <code> fn</code>来表示一个函数：</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">man</span><span>(){
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Hello,World!</span><span>&quot;);
</span><span>}
</span></code></pre>
<p>要带参数直接 <code> name: type</code>写在函数的括号里：</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">man</span><span>(</span><span style="color:#bf616a;">num</span><span>: </span><span style="color:#b48ead;">i32</span><span>){
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Hello,</span><span style="color:#d08770;">{num}</span><span>&quot;);
</span><span>}
</span></code></pre>
<h3 id="yu-ju-he-biao-da-shi">语句和表达式</h3>
<p>语句：执行一些操作，但不返回值</p>
<p>表达式：执行操作，并且返回值。</p>
<p>我们在平时写的 <code> let x = 6</code>就是一个语句，</p>
<p>函数定义也是语句.</p>
<p>所以，不能把 <code>let</code> 语句赋值给另一个变量，如下面这个栗子：</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>(){
</span><span>    </span><span style="color:#b48ead;">let</span><span> x = {</span><span style="color:#b48ead;">let</span><span> y = </span><span style="color:#d08770;">3</span><span>};
</span><span>}
</span></code></pre>
<p>函数调用是一个表达式。宏调用是一个表达式。用大括号创建的一个新的块作用域也是一个表达式，例如：</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>(){
</span><span>    </span><span style="color:#b48ead;">let</span><span> x = {
</span><span>        </span><span style="color:#b48ead;">let</span><span> y = </span><span style="color:#d08770;">2</span><span>;
</span><span>        y + </span><span style="color:#d08770;">2</span><span style="color:#65737e;">//注意这里没有分号，如果有分号就是语句了，不会返回只给x
</span><span>    };
</span><span>    println!(&quot;</span><span style="color:#d08770;">{x}</span><span>&quot;);
</span><span>}
</span></code></pre>
<h3 id="dai-fan-hui-zhi-de-han-shu">带返回值的函数</h3>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">man</span><span>() -&gt; </span><span style="color:#b48ead;">u32</span><span>{
</span><span>    </span><span style="color:#d08770;">5
</span><span>}
</span></code></pre>
<h2 id="kong-zhi-liu">控制流</h2>
<h3 id="ifyu-ju"><code> if</code>语句</h3>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>(){
</span><span>    </span><span style="color:#b48ead;">let</span><span> num = </span><span style="color:#d08770;">5</span><span>;
</span><span>    </span><span style="color:#b48ead;">if</span><span> num &gt; </span><span style="color:#d08770;">4 </span><span>{
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">num is big!</span><span>&quot;);
</span><span>    } </span><span style="color:#b48ead;">else </span><span>{
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">num is small!</span><span>&quot;);
</span><span>    }
</span><span>}
</span></code></pre>
<p>注意，条件一定时 <code> bool</code>类型。</p>
<p>当然，<code> if</code>语句可以直接给变量赋值！</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>(){
</span><span>    </span><span style="color:#b48ead;">let</span><span> condition = </span><span style="color:#d08770;">true</span><span>;
</span><span>    </span><span style="color:#b48ead;">let</span><span> num = </span><span style="color:#b48ead;">if</span><span> condition { </span><span style="color:#d08770;">6 </span><span>} </span><span style="color:#b48ead;">else </span><span>{ </span><span style="color:#d08770;">5 </span><span>};
</span><span>    println!(&quot;</span><span style="color:#d08770;">{num}</span><span>&quot;);
</span><span>}
</span></code></pre>
<h3 id="xun-huan">循环</h3>
<h4 id="loop"><code> loop</code></h4>
<p><code>loop</code> 关键字告诉 Rust 一遍又一遍地执行一段代码直到你明确要求停止。</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>(){
</span><span>    </span><span style="color:#b48ead;">loop </span><span>{
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">Hello,World!</span><span>&quot;);
</span><span>    }
</span><span>}
</span></code></pre>
<p>当然，循环当中也有 <code> break</code>和 <code> continue</code>关键字。</p>
<p>从循环中返回值</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>(){
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> counter = </span><span style="color:#d08770;">0</span><span>;
</span><span>    </span><span style="color:#b48ead;">let</span><span> result = </span><span style="color:#b48ead;">loop </span><span>{
</span><span>        counter += </span><span style="color:#d08770;">1</span><span>;
</span><span>        </span><span style="color:#b48ead;">if</span><span> counter % </span><span style="color:#d08770;">2 </span><span>== </span><span style="color:#d08770;">0</span><span>{
</span><span>            </span><span style="color:#b48ead;">break</span><span> counter * </span><span style="color:#d08770;">2</span><span>;
</span><span>        }
</span><span>    };
</span><span>    println!(&quot;</span><span style="color:#d08770;">{result}</span><span>&quot;);
</span><span>}
</span></code></pre>
<p>循环标签：消除多个循环之间的歧义。</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>(){
</span><span>    &#39;counter1: </span><span style="color:#b48ead;">loop</span><span>{
</span><span>        </span><span style="color:#b48ead;">loop</span><span>{
</span><span>            </span><span style="color:#65737e;">//主要是为了消除多层循环之间的歧义，并不像其他语言那样，直接结束最靠近的那一层循环，也可以结束最外面的循环
</span><span>            </span><span style="color:#b48ead;">break &#39;counter1</span><span>;
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<h4 id="while"><code> while</code></h4>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>(){
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> counter = </span><span style="color:#d08770;">10</span><span>;
</span><span>    </span><span style="color:#b48ead;">while</span><span> counter &gt;= </span><span style="color:#d08770;">5 </span><span>{
</span><span>        println!(&quot;</span><span style="color:#d08770;">{counter}</span><span>&quot;);
</span><span>        counter -= </span><span style="color:#d08770;">1</span><span>;
</span><span>    }
</span><span>    println!(&quot;</span><span style="color:#d08770;">{counter}</span><span>&quot;);
</span><span>}
</span></code></pre>
<h4 id="for"><code> for</code></h4>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>(){
</span><span>    </span><span style="color:#b48ead;">for</span><span> i in </span><span style="color:#d08770;">1</span><span>..</span><span style="color:#d08770;">4 </span><span>{
</span><span>        println!(&quot;</span><span style="color:#d08770;">{i}</span><span>&quot;);
</span><span>    }
</span><span>}
</span></code></pre>
<p>但对于数组而言，</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>(){
</span><span>    </span><span style="color:#b48ead;">let</span><span> nums = [</span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">4</span><span>];
</span><span>    </span><span style="color:#b48ead;">for</span><span> i in nums {
</span><span>        println!(&quot;</span><span style="color:#d08770;">{i}</span><span>&quot;);
</span><span>    }
</span><span>}
</span></code></pre>


            </main>
            <footer>
                
<p class="taxonomies">


<a href="/tags/rust">#Rust</a>



<a href="/categories/rust">+Rust</a>




</p>

                
                <nav>
                    
                    <a href="./atom.xml">RSS</a>
                    
                    <a href="https://github.com/sanhuzhen">Github</a>
                    
                </nav>
                
            </footer>
        </div>
    </body>
</html>